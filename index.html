<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Echo Protocol</title>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=VT323&display=swap" rel="stylesheet">
    
    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    
    <style>
        /* --- GLOBAL & SHARED STYLES --- */
        :root {
            /* This is the initial "Neon Sunset" theme for the splash screen */
            --glow-color: #ff4d94;
            --primary-color: #ff4d94;
            --background-color: #0d001a;
            --enemy-color: #00e5ff;
            /* This is the fixed UI color */
            --fragment-color: #ffe100; 
        }

        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            width: 100%;
            background-color: var(--background-color);
            color: var(--primary-color);
        }
        
        @keyframes fadeIn {
            to { opacity: 1; }
        }

        @keyframes pulse-title {
            0% {
                text-shadow:
                    2px 2px 4px rgba(0,0,0,0.9),  /* Black shadow on top */
                    4px 4px 6px #ff0000,          /* Red shadow behind */
                    0 0 10px #ffe100,          /* Yellow glow */
                    0 0 20px #ffe100;
            }
            50% {
                text-shadow:
                    2px 2px 4px rgba(0,0,0,0.9),
                    4px 4px 6px #ff0000,
                    0 0 20px #ffe100,
                    0 0 30px #ffe100; /* More intense glow */
            }
            100% {
                text-shadow:
                    2px 2px 4px rgba(0,0,0,0.9),
                    4px 4px 6px #ff0000,
                    0 0 10px #ffe100,
                    0 0 20px #ffe100;
            }
        }

        /* --- SPLASH SCREEN STYLES --- */
        #splash-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-shadow: 0 0 5px var(--glow-color), 0 0 10px var(--glow-color), 3px 3px 5px rgba(0,0,0,0.7);
            font-family: 'VT323', monospace;
            cursor: pointer;
        }

        /* --- Centered and enlarged the click prompt --- */
        #click-prompt {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            text-align: center;
            font-family: 'VT323', monospace;
            font-size: 2.5em;
            color: #00ff62;
            text-shadow: 0 0 8px #00ff62;
            animation: pulse-title 2s infinite;
        }

        .hidden-on-load {
            display: none !important; /* Use display none to remove from flow */
        }

        /* --- Style for boot sequence text --- */
        #boot-sequence {
            display: none; /* Hidden by default */
            width: 90%;
            max-width: 800px;
            text-align: center; /* Center the text lines */
            font-size: 2.5em; /* Make it large */
            color: #00ff62;
        }

        .line {
            white-space: pre;
            opacity: 0;
            animation: fadeIn 0.1s forwards;
        }

        /* --- Title layout and animation delays --- */
        #title {
            font-family: 'Orbitron', sans-serif;
            /* TITLE FIX: Use clamp for a responsive font size (min, preferred, max) */
            font-size: clamp(2em, 12vw, 4em);
            text-align: center;
            margin: 20px 0;
            opacity: 0;
            color: #ffe100;
            animation: fadeIn 1s 0.5s forwards, pulse-title 2s infinite 1.5s;
            white-space: nowrap;
            /* TITLE FIX: Add padding and box-sizing to create an invisible bounding box */
            padding: 0 20px;
            box-sizing: border-box;
            width: 100%;
        }

        #game-info {
            text-align: center;
            opacity: 0;
            animation: fadeIn 1s 1s forwards; /* Adjusted animation delays */
            font-size: 0.9em;
            color: #00ff62;
        }
        
        /* --- Combined styles for all buttons --- */
        #start-button, .message-button {
            margin-top: 30px;
            padding: 10px 20px;
            border: 2px solid var(--fragment-color);
            border-radius: 5px;
            background-color: black;
            color: var(--fragment-color);
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2em;
            cursor: pointer;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.9), 2px 2px 3px #ff0000, 0 0 8px var(--fragment-color);
            box-shadow: 0 0 10px var(--fragment-color);
            transition: background-color 0.3s, color 0.3s;
        }
        
        #start-button {
            opacity: 0;
            animation: fadeIn 1s 1.5s forwards; /* Adjusted animation delays */
        }

        #start-button:hover, .message-button:hover {
            background-color: var(--fragment-color);
            color: var(--background-color);
        }

        #background-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* --- MAIN GAME STYLES --- */
        #game-container {
            display: none;
            width: 100%;
            height: 100%;
            position: relative;
            font-family: 'Orbitron', sans-serif;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        /* --- Top bar layout and styling --- */
        #top-bar {
            display: grid;
            grid-template-columns: 1fr auto 1fr; /* SCORE | LIVES | FRAGS */
            width: 100%;
            color: var(--fragment-color); /* UI Color */
            text-shadow: 0 0 8px var(--fragment-color); /* UI Glow */
            border-bottom: 2px solid var(--fragment-color);
            box-shadow: 0 2px 8px -2px var(--fragment-color);
            font-size: clamp(1em, 2.2vw, 1.5em); /* Responsive font size */
        }
        
        #top-bar > div {
            padding: 10px 15px;
        }

        #score { text-align: left; }
        #lives { 
            text-align: center; 
            border-left: 2px solid var(--fragment-color);
            border-right: 2px solid var(--fragment-color);
        }
        #fragments { text-align: right; }

        /* --- Style for message overlays to match buttons --- */
        #message-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 3;
            text-align: center;
            pointer-events: all;
            background: black;
            padding: 2em;
            border-radius: 5px;
            border: 2px solid var(--fragment-color); /* UI Color */
            box-shadow: 0 0 15px var(--fragment-color); /* UI Glow */
            display: none;
        }

        #message-overlay h1 {
            font-size: 3em;
            margin: 0;
            color: var(--fragment-color); /* UI Color */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.9), 2px 2px 3px #ff0000, 0 0 8px var(--fragment-color); /* UI Shadow/Glow */
            animation: pulse-title 2s infinite; /* Correct animation */
        }

        #message-overlay p {
            font-size: 1em;
            margin-bottom: 0;
            color: var(--fragment-color); /* UI Color */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.9), 0 0 5px var(--fragment-color); /* UI Shadow/Glow */
        }
        
        #touch-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 35%;
            z-index: 5;
            display: none;
            pointer-events: none;
        }

        #joystick-area {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 150px;
            height: 150px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            pointer-events: all;
        }
        
        #joystick-knob {
            position: absolute;
            width: 70px;
            height: 70px;
            background: rgba(0, 255, 255, 0.5);
            border-radius: 50%;
            top: 40px;
            left: 40px;
        }

        #shoot-button {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 120px;
            height: 120px;
            background: rgba(255, 0, 127, 0.4);
            border: 2px solid var(--enemy-color);
            border-radius: 50%;
            pointer-events: all;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            color: var(--enemy-color);
            text-shadow: 0 0 5px var(--enemy-color);
        }
        
        @media (max-width: 768px) {
            #top-bar { font-size: 1em; }
            #message-overlay h1 { font-size: 2em; }
            #message-overlay p { font-size: 0.9em; }
        }
    </style>
</head>
<body>

    <!-- Splash Screen Elements -->
    <canvas id="background-canvas"></canvas>
    <div id="splash-container">
        <div id="click-prompt">
            <p>Click to Initiate Boot Sequence</p>
        </div>
        <div id="boot-sequence"></div>
        <h1 id="title" class="hidden-on-load">
            ECHO PROTOCOL
        </h1>
        <div id="game-info" class="hidden-on-load">
            <p>CONTROLS: WASD/Arrows to Move | SPACE to Shoot</p>
            <p>(Touch controls enabled on mobile)</p>
        </div>
        <button id="start-button" class="hidden-on-load">START GAME</button>
    </div>

    <!-- Main Game Elements -->
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="ui-container">
            <div>
                <div id="top-bar">
                    <div id="score">SCORE: 0</div>
                    <div id="lives">LIVES: 3</div>
                    <div id="fragments">FRAGS: 0 / 8</div>
                </div>
            </div>
        </div>
        <!-- Emptied the overlay, content will be generated by JS -->
        <div id="message-overlay"></div>
        <div id="touch-controls">
            <div id="joystick-area">
                <div id="joystick-knob"></div>
            </div>
            <div id="shoot-button">SHOOT</div>
        </div>
    </div>

    <script>
        // --- THEME COLOR MANAGEMENT ---
        const palettes = [
            { // 1. Neon Sunset
                '--glow-color': '#ff4d94',
                '--primary-color': '#ff4d94',
                '--background-color': '#0d001a',
                '--enemy-color': '#00e5ff',
            },
            { // 2. Matrix Green
                '--glow-color': '#33ff33',
                '--primary-color': '#33ff33',
                '--background-color': '#000500',
                '--enemy-color': '#ff3333',
            },
            { // 3. Monochrome Ghost
                '--glow-color': '#ffffff',
                '--primary-color': '#ffffff',
                '--background-color': '#000000',
                '--enemy-color': '#666666',
            },
            { // 4. Infernal Red
                '--glow-color': '#ff3300',
                '--primary-color': '#ff3300',
                '--background-color': '#1a0000',
                '--enemy-color': '#ffcc00',
            },
            { // 5. Oceanic Deep-Sea
                '--glow-color': '#00e6ff',
                '--primary-color': '#00e6ff',
                '--background-color': '#000b14',
                '--enemy-color': '#ff3d71',
            }
        ];

        let glowColor, primaryColor, backgroundColor, enemyColor, fragmentColor, backgroundColorHex;
        
        function applyTheme(palette) {
            const root = document.documentElement;
            for (const [key, value] of Object.entries(palette)) {
                root.style.setProperty(key, value);
            }
        }

        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function updateThemeColors() {
            const computedStyle = getComputedStyle(document.documentElement);
            glowColor = computedStyle.getPropertyValue('--glow-color').trim();
            primaryColor = computedStyle.getPropertyValue('--primary-color').trim();
            backgroundColorHex = computedStyle.getPropertyValue('--background-color').trim();
            enemyColor = computedStyle.getPropertyValue('--enemy-color').trim();
            fragmentColor = computedStyle.getPropertyValue('--fragment-color').trim();
            const r = parseInt(backgroundColorHex.slice(1, 3), 16);
            const g = parseInt(backgroundColorHex.slice(3, 5), 16);
            const b = parseInt(backgroundColorHex.slice(5, 7), 16);
            backgroundColor = `rgb(${r}, ${g}, ${b})`;
        }

        // --- Global Audio Variables ---
        let audioInitialized = false;
        let bassPulse, choirSynth, shootSynth, explosionSynth, alarmSynth, decodedMessageSynth, waveCompleteSynth, bootKeySynth, extraLifeSynth, gameOverSynth, playerCollisionSynth, startGameSynth, keyClatterLoop;
        const fragmentScale = ['C3', 'Eb3', 'G3', 'Bb3', 'C4', 'Eb4', 'G4', 'Bb4'];

        // --- Single, comprehensive audio initialization function ---
        function initAllAudio() {
            if (audioInitialized) return;
            try {
                // Game Synths
                bassPulse = new Tone.PulseOscillator('C1', 0.5).toDestination();
                const bassLFO = new Tone.LFO("4n", 0.5, 1).connect(bassPulse.width);
                bassLFO.start();
                bassPulse.volume.value = -20;
                choirSynth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'fatsawtooth', count: 3, spread: 30 }, envelope: { attack: 1, decay: 0.1, sustain: 1, release: 2 }, volume: -15 }).toDestination();
                shootSynth = new Tone.PolySynth(Tone.MembraneSynth, { pitchDecay: 0.01, octaves: 5, oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.2, sustain: 0 }, volume: -18 }).toDestination();
                explosionSynth = new Tone.PolySynth(Tone.NoiseSynth, { noise: { type: 'white' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0 }, volume: -10 }).toDestination();
                
                // Splash Screen Synths
                alarmSynth = new Tone.MonoSynth({ oscillator: { type: 'square' }, envelope: { attack: 0.1, decay: 0.2, sustain: 0.1, release: 0.5 }, volume: -12 }).toDestination();
                waveCompleteSynth = new Tone.FMSynth({ harmonicity: 1.5, modulationIndex: 8, envelope: { attack: 0.2, decay: 1 }, volume: -5 }).toDestination();
                decodedMessageSynth = new Tone.FMSynth({ harmonicity: 3, modulationIndex: 10, envelope: { attack: 0.01, decay: 0.2 }, volume: -5 }).toDestination();
                
                // --- AUDIO FIX: Halved Keyboard Clatter Length ---
                const keyClatterSynth = new Tone.NoiseSynth({
                    noise: { type: 'brown' }, 
                    envelope: { attack: 0.001, decay: 0.05, sustain: 0 },
                    volume: -25 
                }).toDestination();

                const keyClatterFilter = new Tone.Filter(1500, "bandpass").toDestination(); 
                keyClatterFilter.Q.value = 1.5; 
                keyClatterSynth.connect(keyClatterFilter);
                
                // Sequence is now 5 steps long, half of the previous 10.
                keyClatterLoop = new Tone.Sequence((time, note) => {
                    if (note) { 
                        keyClatterFilter.frequency.setValueAtTime(Math.random() * 2000 + 1000, time);
                        keyClatterSynth.volume.setValueAtTime(Math.random() * 5 - 25, time);
                        keyClatterSynth.triggerAttack(time);
                    }
                }, [
                    'C4', 'C4', null, 'C4', 'C4'
                ], "16n").start(0);

                keyClatterLoop.humanize = true;
                // --- END OF AUDIO FIX ---

                extraLifeSynth = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: 'triangle' },
                    envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 },
                    volume: -8
                }).toDestination();

                // Game Over sound
                gameOverSynth = new Tone.PolySynth(Tone.FMSynth, {
                    harmonicity: 1.2,
                    modulationIndex: 10,
                    envelope: { attack: 0.01, decay: 0.5, sustain: 0.1, release: 1 },
                    volume: -2
                }).toDestination();

                // Player collision sound
                playerCollisionSynth = new Tone.NoiseSynth({
                    noise: { type: 'pink' },
                    envelope: { attack: 0.001, decay: 0.2, sustain: 0 },
                    volume: -5
                }).toDestination();

                // Start game sound
                startGameSynth = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: 'triangle' },
                    envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 },
                    volume: -8
                }).toDestination();

                audioInitialized = true;
            } catch (e) {
                console.error("Audio initialization failed:", e);
                audioInitialized = false;
            }
        }


        // --- SPLASH SCREEN LOGIC ---
        const lines = [
            '> INITIATING ECHO_PROTOCOL.EXE',
            '> LOADING RENDERER... OK',
            '> CALIBRATING GRID... OK',
            '> HINT: PERFECT RUN ENABLED...',
            '> WARNING: DATA STORM DETECTED...',
            '> BOOT SEQUENCE COMPLETE.'
        ];

        let lineIndex = 0;
        function typeLine() {
            if (lineIndex < lines.length) {
                const lineEl = document.createElement('div');
                lineEl.className = 'line';
                lineEl.textContent = lines[lineIndex];
                document.getElementById('boot-sequence').appendChild(lineEl);

                lineIndex++;
                setTimeout(typeLine, 450);
            }
        }
        
        // --- VANILLA JS CANVAS BACKGROUND ---
        let bgAnimationId;
        function initCanvasBackground() {
            const backgroundCanvas = document.getElementById('background-canvas');
            const bgCtx = backgroundCanvas.getContext('2d');
            let fov, cameraZ, cameraY, centerX, centerY;
            const scrollSpeed = 0.5;
            const starSpeed = 0.1;
            const mountainSpeed = 0.2;
            let stars = [], gridPoints = [], mountains = [];

            backgroundCanvas.width = window.innerWidth;
            backgroundCanvas.height = window.innerHeight;
            fov = backgroundCanvas.width * 0.8;
            cameraZ = -5;
            cameraY = 25;
            centerX = backgroundCanvas.width / 2;
            centerY = backgroundCanvas.height / 2;
            stars = [];
            for (let i = 0; i < 500; i++) {
                stars.push({ x: Math.random() * 400 - 200, y: Math.random() * 200 - 100, z: Math.random() * 400 });
            }
            gridPoints = [];
            const gridSize = 30, gridDepth = 30, step = 10;
            for (let z = 0; z < gridDepth; z++) {
                for (let x = 0; x < gridSize; x++) {
                    gridPoints.push({ x: (x - gridSize / 2) * step, y: 50, z: z * step });
                }
            }
            mountains = [];
            const mountainRanges = 2, mountainSegments = 50, mountainWidth = 800;
            for (let i = 0; i < mountainRanges; i++) {
                const range = [];
                const roughness = 5 + i * 5, amplitude = 20 + i * 20, zPos = 150 + i * 80;
                for (let j = 0; j <= mountainSegments; j++) {
                    range.push({ x: (j / mountainSegments - 0.5) * mountainWidth, y: 40 - Math.random() * amplitude, z: zPos + (Math.random() - 0.5) * roughness, offsetZ: 0 });
                }
                mountains.push(range);
            }
            
            function project(p) {
                const z = p.z - cameraZ;
                if (z <= 0) return null;
                const scale = fov / z;
                const x2d = centerX + p.x * scale;
                const y2d = centerY + (p.y - cameraY) * scale;
                return { x: x2d, y: y2d, scale: scale };
            }

            function animateCanvasBackground() {
                bgAnimationId = requestAnimationFrame(animateCanvasBackground);
                bgCtx.fillStyle = backgroundColor;
                bgCtx.fillRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
                bgCtx.fillStyle = 'rgba(0, 255, 255, 0.8)';
                stars.forEach(star => {
                    star.z -= starSpeed;
                    if (star.z < cameraZ) star.z = 400;
                    const p = project(star);
                    if (p) bgCtx.fillRect(p.x, p.y, p.scale * 1.5, p.scale * 1.5);
                });
                bgCtx.strokeStyle = hexToRgba(primaryColor, 0.3);
                bgCtx.lineWidth = 1;
                mountains.forEach((range, index) => {
                    range.forEach(p => { p.offsetZ = (p.offsetZ - mountainSpeed * (index + 1)) % 200; });
                    bgCtx.beginPath();
                    let firstPoint = true;
                    for (let i = 0; i < range.length; i++) {
                        const p3d = { x: range[i].x, y: range[i].y, z: range[i].z + range[i].offsetZ };
                        const p2d = project(p3d);
                        if (p2d) {
                            if (firstPoint) { bgCtx.moveTo(p2d.x, p2d.y); firstPoint = false; } 
                            else { bgCtx.lineTo(p2d.x, p2d.y); }
                        }
                    }
                    bgCtx.stroke();
                });
                const horizonY = centerY;
                bgCtx.fillStyle = hexToRgba(backgroundColorHex, 0.9);
                bgCtx.fillRect(0, horizonY, backgroundCanvas.width, backgroundCanvas.height - horizonY);
                bgCtx.strokeStyle = 'rgba(255, 0, 255, 0.2)';
                bgCtx.lineWidth = 0.5;
                gridPoints.forEach(p => {
                    p.z -= scrollSpeed;
                    if (p.z < cameraZ) p.z += 300;
                });
                const gridSize = 30;
                for (let z = 0; z < 29; z++) {
                    for (let x = 0; x < 29; x++) {
                        const p1 = project(gridPoints[z * gridSize + x]);
                        const p2 = project(gridPoints[z * gridSize + x + 1]);
                        const p3 = project(gridPoints[(z + 1) * gridSize + x]);
                        if (p1 && p2) { bgCtx.beginPath(); bgCtx.moveTo(p1.x, p1.y); bgCtx.lineTo(p2.x, p2.y); bgCtx.stroke(); }
                        if (p1 && p3) { bgCtx.beginPath(); bgCtx.moveTo(p1.x, p1.y); bgCtx.lineTo(p3.x, p3.y); bgCtx.stroke(); }
                    }
                }
            }
            if(bgAnimationId) cancelAnimationFrame(bgAnimationId);
            animateCanvasBackground();
        }

        window.addEventListener('resize', initCanvasBackground, false);

        function playTitleSoundSequence() {
            if (!audioInitialized) return;
            const now = Tone.now();
            fragmentScale.forEach((note, index) => {
                decodedMessageSynth.triggerAttackRelease(note, '16n', now + index * 0.12);
            });
        }

        // --- MAIN GAME LOGIC (WRAPPED IN A FUNCTION) ---
        function launchGame() {
            const splashContainer = document.getElementById('splash-container');
            const backgroundCanvas = document.getElementById('background-canvas');
            const gameContainer = document.getElementById('game-container');
            
            cancelAnimationFrame(bgAnimationId);
            splashContainer.style.display = 'none';
            backgroundCanvas.style.display = 'none';
            gameContainer.style.display = 'block';

            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const scoreEl = document.getElementById('score');
            const livesEl = document.getElementById('lives');
            const fragmentsEl = document.getElementById('fragments');
            const messageOverlay = document.getElementById('message-overlay');
            const touchControls = document.getElementById('touch-controls');
            const joystickArea = document.getElementById('joystick-area');
            const joystickKnob = document.getElementById('joystick-knob');
            const shootButton = document.getElementById('shoot-button');
            let width, height;
            let gameState = 'start';
            let score = 0;
            const initialLives = 3;
            let lives = initialLives;
            let wave = 1;
            let nextLifeScore = 100000;
            let fragmentsRescued = 0, fragmentsLost = 0, totalFragments = 8, fragmentsSpawned = 0;
            let waveFragmentScore = 0; 
            let fragmentSpawnTimer = 0;
            let perfectRun = true;
            let lastTime = 0;
            let animationFrameId;
            let player, landscape, dataStorm;
            let bullets = [], enemies = [], fragments = [], particles = [];
            const keys = {};
            let isShooting = false, joystickActive = false;
            let joystickStart = { x: 0, y: 0 }, joystickCurrent = { x: 0, y: 0 };
            let activeChoirNotes = [];

            class Player {
                constructor() { this.x = width / 4; this.y = height / 2; this.width = 30; this.height = 15; this.speed = 5; this.vx = 0; this.vy = 0; this.friction = 0.9; this.trail = []; this.shootCooldown = 0; this.maxFollowing = 4; this.isInvincible = false; this.invincibilityTimer = 0; this.invincibilityDuration = 180; this.rescueMultiplier = 0; }
                update() {
                    if (this.isInvincible) { this.invincibilityTimer--; if (this.invincibilityTimer <= 0) this.isInvincible = false; }
                    let moveX = 0, moveY = 0;
                    if (keys['w'] || keys['arrowup']) moveY = -1;
                    if (keys['s'] || keys['arrowdown']) moveY = 1;
                    if (keys['a'] || keys['arrowleft']) moveX = -1;
                    if (keys['d'] || keys['arrowright']) moveX = 1;
                    if (joystickActive) { const dx = joystickCurrent.x - joystickStart.x, dy = joystickCurrent.y - joystickStart.y; if (Math.sqrt(dx*dx + dy*dy) > 10) { moveX = dx / 50; moveY = dy / 50; } }
                    this.vx += moveX * 0.5; this.vy += moveY * 0.5; this.vx *= this.friction; this.vy *= this.friction;
                    this.x += this.vx; this.y += this.vy;
                    if (this.x < this.width / 2) this.x = this.width / 2; if (this.x > width - this.width / 2) this.x = width - this.width / 2; if (this.y < this.height / 2) this.y = this.height / 2; if (this.y > height - this.height / 2) this.y = height - this.height / 2;
                    this.trail.push({ x: this.x, y: this.y }); if (this.trail.length > 20) this.trail.shift();
                    if (this.shootCooldown > 0) this.shootCooldown--; if (isShooting && this.shootCooldown === 0) { this.shoot(); this.shootCooldown = 10; }
                    if(audioInitialized) { const velocityMagnitude = Math.sqrt(this.vx * this.vx + this.vy * this.vy); bassPulse.volume.value = Tone.gainToDb(velocityMagnitude / 15); }
                
                    const followingCount = fragments.filter(f => f.state === 'following').length;
                    if (followingCount === 0) {
                        this.rescueMultiplier = 0;
                    } else if (this.x < 100 && this.rescueMultiplier === 0) {
                        this.rescueMultiplier = followingCount;
                    } else if (this.x > 150) {
                        this.rescueMultiplier = 0;
                    }
                }
                shoot() { bullets.push(new Bullet(this.x + this.width / 2, this.y)); if(audioInitialized) shootSynth.triggerAttackRelease("C5", "8n"); }
                draw() {
                    if (this.isInvincible && Math.floor(this.invincibilityTimer / 6) % 2 === 0) return;
                    ctx.beginPath(); if (this.trail.length > 0) { ctx.moveTo(this.trail[0].x, this.trail[0].y); for (let i = 1; i < this.trail.length; i++) { const alpha = i / this.trail.length; ctx.strokeStyle = hexToRgba(primaryColor, alpha * 0.5); ctx.lineWidth = 2; ctx.lineTo(this.trail[i].x, this.trail[i].y); } ctx.stroke(); }
                    ctx.fillStyle = primaryColor; ctx.shadowColor = glowColor; ctx.shadowBlur = 15;
                    ctx.beginPath(); ctx.moveTo(this.x + this.width / 2, this.y); ctx.lineTo(this.x - this.width / 2, this.y - this.height / 2); ctx.lineTo(this.x - this.width / 2, this.y + this.height / 2); ctx.closePath(); ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }
            class Bullet { constructor(x, y) { this.x = x; this.y = y; this.width = 10; this.height = 2; this.speed = 10; } update() { this.x += this.speed; } draw() { ctx.fillStyle = primaryColor; ctx.shadowColor = glowColor; ctx.shadowBlur = 10; ctx.fillRect(this.x, this.y - this.height / 2, this.width, this.height); ctx.shadowBlur = 0; } }
            class Fragment {
                constructor(x, y, index) { this.x = x; this.y = y; this.size = 10; this.state = 'idle'; this.target = null; this.trail = []; this.index = index; this.speedX = -1; }
                update() {
                    if (this.state === 'idle') { 
                        this.x += this.speedX; 
                        if (this.x < -this.size) {
                            this.state = 'lost';
                            fragmentsLost++;
                            perfectRun = false;
                        }
                    }
                    else if (this.state === 'following') {
                        const dx = this.target.x - this.x - 50 - (fragments.filter(f => f.state === 'following').indexOf(this) * 20); const dy = this.target.y - this.y;
                        this.x += dx * 0.05; this.y += dy * 0.05;
                        this.trail.push({ x: this.x, y: this.y }); if (this.trail.length > 15) this.trail.shift();
                        if (this.x < 20) { 
                            this.state = 'rescued'; 
                            fragmentsRescued++; 
                            const multiplier = Math.max(1, player.rescueMultiplier);
                            const points = 1000 * multiplier;
                            score += points;
                            waveFragmentScore += points;
                            if(audioInitialized) { 
                                const note = fragmentScale[this.index % fragmentScale.length]; 
                                choirSynth.triggerAttack(note); 
                                activeChoirNotes.push(note); 
                            } 
                        }
                    }
                }
                draw() {
                    if (this.state === 'following') { ctx.beginPath(); if(this.trail.length > 0) ctx.moveTo(this.trail[0].x, this.trail[0].y); for (let i = 1; i < this.trail.length; i++) { const alpha = i / this.trail.length; ctx.strokeStyle = hexToRgba(fragmentColor, alpha * 0.5); ctx.lineWidth = 2; ctx.lineTo(this.trail[i].x, this.trail[i].y); } ctx.stroke(); }
                    ctx.fillStyle = fragmentColor; ctx.shadowColor = fragmentColor; ctx.shadowBlur = 15; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = 'black'; ctx.beginPath(); ctx.moveTo(this.x, this.y - this.size * 0.6); ctx.lineTo(this.x + this.size * 0.6, this.y); ctx.lineTo(this.x, this.y + this.size * 0.6); ctx.lineTo(this.x - this.size * 0.6, this.y); ctx.closePath(); ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }
            class Enemy { 
                constructor(wave) { this.x = width + 50; this.y = Math.random() * height; this.size = 20; this.speedX = - (2 + Math.random() * 2 + wave * 0.3); this.speedY = (Math.random() - 0.5) * 2; this.type = (Math.random() < (0.15 + wave * 0.04)) ? 'seeker' : 'drifter'; this.color = enemyColor; } 
                update() { if (this.type === 'seeker' && player) { const dy = player.y - this.y; this.speedY = dy * 0.015; } this.x += this.speedX; this.y += this.speedY; } 
                draw() { ctx.fillStyle = this.color; ctx.shadowColor = this.color; ctx.shadowBlur = 15; ctx.beginPath(); ctx.moveTo(this.x, this.y - this.size / 2); ctx.lineTo(this.x + this.size / 2, this.y); ctx.lineTo(this.x, this.y + this.size / 2); ctx.lineTo(this.x - this.size / 2, this.y); ctx.closePath(); ctx.fill(); ctx.shadowBlur = 0; } 
            }
            class Particle { constructor(x, y, color) { this.x = x; this.y = y; this.size = Math.random() * 5 + 1; this.vx = (Math.random() - 0.5) * 5; this.vy = (Math.random() - 0.5) * 5; this.life = 1; this.color = color; } update() { this.x += this.vx; this.y += this.vy; this.life -= 0.02; } draw() { ctx.fillStyle = this.color; ctx.globalAlpha = this.life; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1.0; } }
            class WireframeLandscape { 
                constructor() { this.points = []; this.scrollSpeed = 0.5; this.generatePoints(); } 
                generatePoints() { this.points = []; for(let i = 0; i < width * 2 / 50 + 2; i++) { this.points.push({ x: i * 50, y1: height - (Math.random() * height / 4), y2: height - (Math.random() * height / 8), }); } } 
                update() { this.points.forEach(p => p.x -= this.scrollSpeed); if(this.points.length > 0 && this.points[0].x < -50) { this.points.shift(); this.points.push({ x: this.points[this.points.length - 1].x + 50, y1: height - (Math.random() * height / 4), y2: height - (Math.random() * height / 8), }); } } 
                draw() { ctx.strokeStyle = hexToRgba(primaryColor, 0.3); ctx.lineWidth = 1; ctx.shadowColor = glowColor; ctx.shadowBlur = 10; if (this.points.length > 0) { ctx.beginPath(); ctx.moveTo(this.points[0].x, this.points[0].y2); for(let i = 1; i < this.points.length; i++) ctx.lineTo(this.points[i].x, this.points[i].y2); ctx.stroke(); ctx.beginPath(); ctx.moveTo(this.points[0].x, this.points[0].y1); for(let i = 1; i < this.points.length; i++) ctx.lineTo(this.points[i].x, this.points[i].y1); ctx.stroke(); ctx.beginPath(); for(let i = 0; i < this.points.length; i++) { ctx.moveTo(this.points[i].x, this.points[i].y1); ctx.lineTo(this.points[i].x, height); } for(let y = height; y > height * 0.6; y -= 20) { ctx.moveTo(0, y); ctx.lineTo(width, y); } ctx.strokeStyle = hexToRgba(primaryColor, 0.1); ctx.stroke(); } ctx.shadowBlur = 0; } 
            }
            class DataStorm { constructor() { this.particles = []; for(let i = 0; i < 100; i++) { this.particles.push({ x: Math.random() * width, y: Math.random() * height, z: Math.random() * width, size: 1 }); } } update() { this.particles.forEach(p => { p.z -= 1; if(p.z <= 0) { p.z = width; p.x = Math.random() * width; p.y = Math.random() * height; } }); } draw() { ctx.fillStyle = hexToRgba(primaryColor, 0.5); this.particles.forEach(p => { const scale = width / (width + p.z); const x2d = (p.x - width / 2) * scale + width / 2; const y2d = (p.y - height / 2) * scale + height / 2; const size = scale * p.size; ctx.fillRect(x2d, y2d, size, size); }); } }

            function startWave(waveNumber) {
                gameState = 'wave_end'; wave = waveNumber;
                const themeIndex = (waveNumber - 1) % palettes.length;
                applyTheme(palettes[themeIndex]);
                updateThemeColors();
                const perfectBonus = perfectRun ? 5000 : 0;
                score += perfectBonus; // Fragment score is already added during gameplay
                
                // Clear and build the wave complete message
                messageOverlay.innerHTML = '';
                const title = document.createElement('h1');
                const subtext = document.createElement('p');

                title.textContent = `WAVE ${wave - 1} COMPLETE`;
                let bonusText = `Fragment Bonus: ${waveFragmentScore}`; if (perfectRun) bonusText += ` | PERFECT: ${perfectBonus}`;
                subtext.innerHTML = bonusText;
                
                messageOverlay.appendChild(title);
                messageOverlay.appendChild(subtext);
                messageOverlay.style.display = 'block';

                if(audioInitialized) waveCompleteSynth.triggerAttackRelease("C3", "2s");
                
                // Automatic progression after 4 seconds
                setTimeout(() => {
                    fragmentsRescued = 0; fragmentsLost = 0; fragmentsSpawned = 0; fragmentSpawnTimer = 0; perfectRun = true; waveFragmentScore = 0;
                    fragments = []; enemies = []; bullets = []; if(audioInitialized) choirSynth.releaseAll(); activeChoirNotes = [];
                    
                    // Show "Get Ready" message
                    messageOverlay.innerHTML = '';
                    title.textContent = `WAVE ${wave}`;
                    subtext.textContent = 'Get Ready...';
                    messageOverlay.appendChild(title);
                    messageOverlay.appendChild(subtext);

                    setTimeout(() => { messageOverlay.style.display = 'none'; gameState = 'playing'; }, 2000);
                }, 4000);
            }

            function startGame() {
                if(audioInitialized) {
                    const now = Tone.now();
                    const notes = ['C4', 'E4', 'G4', 'C5'];
                    notes.forEach((note, i) => {
                        startGameSynth.triggerAttackRelease(note, '16n', now + i * 0.07);
                    });
                }
                applyTheme(palettes[0]);
                updateThemeColors();
                if(audioInitialized) bassPulse.start();
                score = 0; lives = initialLives; wave = 1; nextLifeScore = 100000;
                fragmentsRescued = 0; fragmentsLost = 0; fragmentsSpawned = 0; fragmentSpawnTimer = 0; perfectRun = true; waveFragmentScore = 0;
                player = new Player(); bullets = []; enemies = []; particles = []; fragments = [];
                landscape = new WireframeLandscape(); dataStorm = new DataStorm();
                messageOverlay.style.display = 'none'; gameState = 'playing';
                lastTime = performance.now();
                if(animationFrameId) cancelAnimationFrame(animationFrameId);
                animate(lastTime);
            }

            function loseLife() {
                if (player.isInvincible) return;
                lives--;
                for (let i = 0; i < 30; i++) particles.push(new Particle(player.x, player.y, primaryColor));
                if(audioInitialized) playerCollisionSynth.triggerAttackRelease("8n");
                if (lives < 0) endGame('lose');
                else { player.isInvincible = true; player.invincibilityTimer = player.invincibilityDuration; player.x = width / 4; player.y = height / 2; player.vx = 0; player.vy = 0; }
            }

            function update(dt) {
                if (gameState !== 'playing') return;
                player.update(); landscape.update(); dataStorm.update();
                bullets = bullets.filter(b => b.x < width); bullets.forEach(b => b.update());
                const enemyCount = 5 + wave * 2; if (Math.random() < (0.02 + wave * 0.002) && enemies.length < enemyCount) enemies.push(new Enemy(wave));
                enemies = enemies.filter(e => e.x > -e.size); enemies.forEach(e => e.update());
                fragmentSpawnTimer -= dt; if (fragmentSpawnTimer <= 0 && fragmentsSpawned < totalFragments) { fragments.push(new Fragment(width + 20, Math.random() * height, fragmentsSpawned)); fragmentsSpawned++; fragmentSpawnTimer = Math.max(3, 15 - wave * 0.75); }
                fragments = fragments.filter(f => f.state !== 'rescued' && f.state !== 'lost'); fragments.forEach(f => f.update());
                if(audioInitialized && enemies.length > 7 && Math.random() < 0.05) alarmSynth.triggerAttackRelease("G5", "16n");
                particles = particles.filter(p => p.life > 0); particles.forEach(p => p.update());
                bullets.forEach((bullet, bIndex) => { enemies.forEach((enemy, eIndex) => { if (bullet.x < enemy.x + enemy.size && bullet.x + bullet.width > enemy.x && bullet.y < enemy.y + enemy.size && bullet.y + bullet.height > enemy.y) { for (let i = 0; i < 20; i++) particles.push(new Particle(enemy.x, enemy.y, enemy.color)); if(audioInitialized) explosionSynth.triggerAttackRelease("8n"); enemies.splice(eIndex, 1); bullets.splice(bIndex, 1); score += 100; } }); });
                fragments.forEach(fragment => { if (fragment.state === 'idle') { const dx = player.x - fragment.x, dy = player.y - fragment.y; const dist = Math.sqrt(dx * dx + dy * dy); const followingCount = fragments.filter(f => f.state === 'following').length; if (dist < 50 && followingCount < player.maxFollowing) { fragment.state = 'following'; fragment.target = player; } } });
                enemies.forEach(enemy => { if (player.isInvincible) return; const dx = player.x - enemy.x, dy = player.y - enemy.y; const dist = Math.sqrt(dx * dx + dy * dy); if (dist < player.width / 2 + enemy.size / 2) loseLife(); });
                enemies.forEach(enemy => { fragments.forEach((fragment, fIndex) => { if (fragment.state === 'following') { const dx = enemy.x - fragment.x, dy = enemy.y - fragment.y; const dist = Math.sqrt(dx * dx + dy * dy); if (dist < enemy.size / 2 + fragment.size) { for (let i = 0; i < 15; i++) particles.push(new Particle(fragment.x, fragment.y, fragmentColor)); if(audioInitialized) { explosionSynth.triggerAttackRelease("4n"); const note = fragmentScale[fragment.index % fragmentScale.length]; choirSynth.triggerRelease(note); activeChoirNotes = activeChoirNotes.filter(n => n !== note); } fragments.splice(fIndex, 1); perfectRun = false; fragmentsLost++; } } }); });
                if (fragmentsRescued + fragmentsLost >= totalFragments) startWave(wave + 1);
                
                if (score >= nextLifeScore) {
                    lives++;
                    nextLifeScore += 100000;
                    if(audioInitialized) {
                        const now = Tone.now();
                        extraLifeSynth.triggerAttackRelease(['C4', 'E4', 'G4', 'C5'], '8n', now);
                    }
                }
            }

            function draw() {
                ctx.clearRect(0, 0, width, height);
                if (dataStorm) dataStorm.draw(); if (landscape) landscape.draw();
                
                drawWaveBackground();

                particles.forEach(p => p.draw()); fragments.forEach(f => { if(f.state !== 'rescued') f.draw(); });
                enemies.forEach(e => e.draw()); bullets.forEach(b => b.draw()); if (player) player.draw();
                scoreEl.textContent = `SCORE: ${score}`; 
                livesEl.textContent = `LIVES: ${Math.max(0, lives)}`; 
                fragmentsEl.textContent = `FRAGS: ${fragmentsRescued} / ${totalFragments}`;
            }
            
            function drawWaveBackground() {
                ctx.save();
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                ctx.fillStyle = hexToRgba(primaryColor, 0.1);

                ctx.font = `bold clamp(2em, 5vw, 3em) 'Orbitron', sans-serif`;
                ctx.fillText('WAVE', width / 2, height * 0.3);

                ctx.font = `bold clamp(10em, 25vw, 20em) 'Orbitron', sans-serif`;
                ctx.fillText(wave, width / 2, height * 0.6);

                ctx.restore();
            }
            
            function endGame(reason) {
                gameState = 'lose'; cancelAnimationFrame(animationFrameId); animationFrameId = null;
                if(audioInitialized) { 
                    bassPulse.stop(); 
                    choirSynth.releaseAll(); 
                    activeChoirNotes = []; 
                    const now = Tone.now();
                    const reversedScale = [...fragmentScale].reverse();
                    reversedScale.forEach((note, index) => {
                        decodedMessageSynth.triggerAttackRelease(note, '16n', now + index * 0.15);
                    });
                }
                
                messageOverlay.innerHTML = '';
                const title = document.createElement('h1');
                const subtext = document.createElement('p');
                const restartButton = document.createElement('button');

                title.textContent = "GAME OVER";
                subtext.innerHTML = `You reached Wave ${wave}<br>Final Score: ${score}`;
                restartButton.textContent = 'RESTART';
                restartButton.className = 'message-button';
                restartButton.id = 'restart-button'; 

                messageOverlay.appendChild(title);
                messageOverlay.appendChild(subtext);
                messageOverlay.appendChild(restartButton);
                messageOverlay.style.display = 'block';
                
                restartButton.addEventListener('click', (e) => {
                    e.stopPropagation(); 
                    launchGame();
                });
            }

            function animate(timestamp) {
                if (gameState === 'lose') return;
                const dt = (timestamp - lastTime) / 1000; lastTime = timestamp;
                if (gameState === 'playing') update(dt);
                draw();
                animationFrameId = requestAnimationFrame(animate);
            }

            function resizeGame() {
                width = window.innerWidth; height = window.innerHeight;
                canvas.width = width; canvas.height = height;
                if(landscape) landscape.generatePoints();
            }

            function handlePointerDown(e) {
                 if (gameState === 'playing') {
                    if (e.target === shootButton) isShooting = true;
                    else if (e.target === joystickArea || e.target === joystickKnob) {
                        joystickActive = true; const touch = e.touches[0];
                        joystickStart.x = touch.clientX; joystickStart.y = touch.clientY;
                        joystickCurrent.x = touch.clientX; joystickCurrent.y = touch.clientY;
                    }
                }
            }

            function handlePointerMove(e) { if (joystickActive) { e.preventDefault(); const touch = e.touches[0]; joystickCurrent.x = touch.clientX; joystickCurrent.y = touch.clientY; const dx = joystickCurrent.x - joystickStart.x, dy = joystickCurrent.y - joystickStart.y; const dist = Math.min(50, Math.sqrt(dx*dx + dy*dy)); const angle = Math.atan2(dy, dx); const knobX = 40 + dist * Math.cos(angle); const knobY = 40 + dist * Math.sin(angle); joystickKnob.style.transform = `translate(${knobX}px, ${knobY}px)`; } }
            function handlePointerUp(e) { isShooting = false; if (joystickActive) { joystickActive = false; joystickKnob.style.transform = `translate(40px, 40px)`; } }

            window.addEventListener('resize', resizeGame);
            window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; if (e.key === ' ') { e.preventDefault(); isShooting = true; } });
            window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; if (e.key === ' ') isShooting = false; });
            
            const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
            if (isTouchDevice) {
                touchControls.style.display = 'block';
                joystickArea.addEventListener('touchstart', handlePointerDown, { passive: false });
                shootButton.addEventListener('touchstart', handlePointerDown, { passive: false });
                window.addEventListener('touchmove', handlePointerMove, { passive: false });
                window.addEventListener('touchend', handlePointerUp);
                window.addEventListener('touchcancel', handlePointerUp);
            }
            resizeGame();
            startGame();
        }

        // --- UPDATED: Start Splash Screen Logic ---
        window.onload = () => {
            updateThemeColors();
            initCanvasBackground();
            
            const clickPrompt = document.getElementById('click-prompt');
            const bootSequenceEl = document.getElementById('boot-sequence');
            const titleEl = document.getElementById('title');
            const gameInfoEl = document.getElementById('game-info');
            const startButton = document.getElementById('start-button');
            const splashContainer = document.getElementById('splash-container');
            const messageOverlay = document.getElementById('message-overlay');

            // NEW: Function to handle Enter key presses
            const handleEnterKey = (e) => {
                if (e.key !== 'Enter') return;

                const startButtonVisible = startButton.style.display !== 'none';
                const restartButton = document.getElementById('restart-button');

                if (startButtonVisible && splashContainer.style.display !== 'none') {
                    startButton.click();
                } else if (restartButton && messageOverlay.style.display === 'block') {
                    restartButton.click();
                }
            };
            
            startButton.addEventListener('click', launchGame);

            splashContainer.addEventListener('click', () => {
                clickPrompt.style.display = 'none';
                bootSequenceEl.style.display = 'block';

                // TIMING FIX: The entire boot sequence logic is now placed inside the
                // promise chain to ensure the audio context is ready before anything starts.
                Tone.start().then(initAllAudio).then(() => {
                    // 1. Start audio transport for the keyboard sound.
                    if (keyClatterLoop) {
                        Tone.Transport.start();
                    }
                    
                    // 2. Start the visual typing animation.
                    typeLine(); 

                    // 3. Add the Enter key listener after the first interaction.
                    window.addEventListener('keydown', handleEnterKey);

                    // 4. Set a timeout to end the boot sequence and show the title screen.
                    const bootDuration = lines.length * 450 + 1000;

                    setTimeout(() => {
                        if (keyClatterLoop) {
                            Tone.Transport.stop();
                            keyClatterLoop.dispose();
                        }
                        bootSequenceEl.style.display = 'none';

                        // Make the title screen elements visible by removing the class
                        titleEl.classList.remove('hidden-on-load');
                        gameInfoEl.classList.remove('hidden-on-load');
                        startButton.classList.remove('hidden-on-load');

                        // Set display back to flex for proper centering
                        splashContainer.style.display = 'flex';

                        setTimeout(() => {
                            playTitleSoundSequence();
                        }, 500); // Matches the new animation delay for the title

                    }, bootDuration);
                });
            }, { once: true });
        };

    </script>
</body>
</html>
