<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Echo Protocol</title>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=VT323&display=swap" rel="stylesheet">
    
    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    
    <style>
        /* --- GLOBAL & SHARED STYLES --- */
        :root {
            /* --- Constant Player Colors --- */
            --player-main-color: #00aaff;
            --player-dark-color: #2b2b44;
            --player-light-color: #66ccff;
            --player-accent-color: #ffae42;
            --player-cockpit-color: #ffffff;

            /* --- Constant Fragment Colors --- */
            --fragment-main-color: #33ff33;
            --fragment-dark-color: #1d6914;
            --fragment-light-color: #90ee90;
            --fragment-accent-color-ship: #ffff00;
            --fragment-accent-color-ui: #ffe100; /* For UI elements */

            /* --- Wave-dependent Theme Colors (Initial values for Wave 1) --- */
            --glow-color: #ff4d94;
            --background-color: #0d001a;
            --enemy-color: #00ffff;
            --enemy-dark-color: #008080;
            --enemy-light-color: #99ffff;
            --enemy-accent-color: #ff66ff;
        }

        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            background-color: #000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        @keyframes fadeIn {
            to { opacity: 1; }
        }

        @keyframes pulse-title {
            0% {
                text-shadow:
                    2px 2px 4px rgba(0,0,0,0.9),  /* Black shadow on top */
                    4px 4px 6px #ff0000,        /* Red shadow behind */
                    0 0 10px #ffe100,       /* Yellow glow */
                    0 0 20px #ffe100;
            }
            50% {
                text-shadow:
                    2px 2px 4px rgba(0,0,0,0.9),
                    4px 4px 6px #ff0000,
                    0 0 20px #ffe100,
                    0 0 30px #ffe100; /* More intense glow */
            }
            100% {
                text-shadow:
                    2px 2px 4px rgba(0,0,0,0.9),
                    4px 4px 6px #ff0000,
                    0 0 10px #ffe100,
                    0 0 20px #ffe100;
            }
        }
        
        #main-container {
            width: 800px;
            height: 600px;
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            overflow: hidden;
        }

        /* --- CRT OVERLAY STYLES --- */
        #crt-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
        }

        #crt-overlay::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), 
                linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 4px, 6px 100%;
            z-index: 2;
        }

        #crt-overlay::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(18, 16, 16, 0.1);
            opacity: 0;
            animation: flicker 4s infinite;
            box-shadow: inset 0 0 2cm rgba(0,0,0,0.8), inset 0 0 20px 5px var(--glow-color);
            z-index: 1;
        }

        @keyframes flicker {
            0% { opacity: 0.15; }
            1% { opacity: 0.1; }
            2% { opacity: 0.2; }
            3% { opacity: 0.12; }
            4% { opacity: 0.15; }
            100% { opacity: 0.15; }
        }


        /* --- SPLASH SCREEN STYLES --- */
        #splash-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-shadow: 0 0 5px var(--glow-color), 0 0 10px var(--glow-color), 3px 3px 5px rgba(0,0,0,0.7);
            font-family: 'VT323', monospace;
            cursor: pointer;
            background-color: var(--background-color);
        }

        /* --- Centered and enlarged the click prompt --- */
        #click-prompt {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            text-align: center;
            font-family: 'VT323', monospace;
            font-size: 2.5em;
            color: #00ff62;
            text-shadow: 0 0 8px #00ff62;
            animation: pulse-title 2s infinite;
            z-index: 2; /* Ensure it's above the background canvas */
        }

        .hidden-on-load {
            display: none !important; /* Use display none to remove from flow */
        }

        /* --- Style for boot sequence text --- */
        #boot-sequence {
            display: none; /* Hidden by default */
            width: 90%;
            max-width: 800px;
            text-align: center; /* Center the text lines */
            font-size: 2.5em; /* Make it large */
            color: #00ff62;
            position: relative; /* Establish stacking context */
            z-index: 2;
        }

        .line {
            white-space: pre;
            opacity: 0;
            animation: fadeIn 0.1s forwards;
        }

        /* --- Title layout and animation delays --- */
        #title {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(2.5em, 10vw, 4.2em); /* Responsive font size */
            text-align: center;
            margin: 20px 0;
            opacity: 0;
            color: #ffe100;
            animation: fadeIn 1s 0.5s forwards, pulse-title 2s infinite 1.5s;
            padding: 0 20px;
            box-sizing: border-box;
            width: 100%;
            position: relative;
            z-index: 2;
        }

        #game-info {
            text-align: center;
            opacity: 0;
            animation: fadeIn 1s 1s forwards;
            font-size: 0.9em;
            color: #00ff62;
            position: relative; /* Establish stacking context */
            z-index: 2;
        }
        
        /* --- Combined styles for all buttons --- */
        #start-button, .message-button {
            margin-top: 30px;
            padding: 10px 20px;
            border: 2px solid var(--fragment-accent-color-ui);
            border-radius: 5px;
            background-color: black;
            color: var(--fragment-accent-color-ui);
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2em;
            cursor: pointer;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.9), 2px 2px 3px #ff0000, 0 0 8px var(--fragment-accent-color-ui);
            box-shadow: 0 0 10px var(--fragment-accent-color-ui);
            transition: background-color 0.3s, color 0.3s;
        }
        
        #start-button {
            opacity: 0;
            animation: fadeIn 1s 1.5s forwards;
            position: relative; /* Establish stacking context */
            z-index: 2;
        }

        #start-button:hover, .message-button:hover {
            background-color: var(--fragment-accent-color-ui);
            color: var(--background-color);
        }

        #background-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1; /* Place it above the background color but below UI */
        }

        /* --- MAIN GAME STYLES --- */
        #game-container {
            display: none;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            font-family: 'Orbitron', sans-serif;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            image-rendering: pixelated; /* Ensures pixel art scales crisply */
        }

        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3; 
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        /* --- Top bar layout and styling --- */
        #top-bar {
            display: grid;
            grid-template-columns: 1fr auto 1fr; /* SCORE | LIVES | FRAGS */
            width: 100%;
            color: var(--fragment-accent-color-ui); /* UI Color */
            text-shadow: 0 0 8px var(--fragment-accent-color-ui); /* UI Glow */
            border-bottom: 2px solid var(--fragment-accent-color-ui);
            box-shadow: 0 2px 8px -2px var(--fragment-accent-color-ui);
            font-size: clamp(1em, 2.2vw, 1.5em); /* Responsive font size */
        }
        
        #top-bar > div {
            padding: 10px 15px;
            display: flex;
            align-items: center;
        }

        #score { justify-content: flex-start; }
        #lives { 
            justify-content: center;
            border-left: 2px solid var(--fragment-accent-color-ui);
            border-right: 2px solid var(--fragment-accent-color-ui);
        }
        
        /* --- Fragment Status Bar --- */
        #fragment-status {
            justify-content: flex-end;
            gap: 8px;
        }
        #fragment-icons {
            display: flex;
            gap: 5px;
        }
        .fragment-icon {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            transition: background-color 0.3s, box-shadow 0.3s;
        }
        .fragment-icon.unspawned {
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .fragment-icon.in_play {
            background-color: var(--fragment-main-color);
            border: 1px solid var(--fragment-light-color);
            box-shadow: 0 0 8px var(--fragment-main-color);
            animation: pulse-icon 1.5s infinite;
        }
        .fragment-icon.following {
            background-color: var(--player-main-color);
            border: 1px solid var(--player-light-color);
            box-shadow: 0 0 8px var(--player-main-color);
        }
        .fragment-icon.rescued {
            background-color: var(--fragment-accent-color-ui);
            border: 1px solid #ffff66;
            box-shadow: 0 0 8px var(--fragment-accent-color-ui);
        }
        .fragment-icon.lost {
            background-color: #ff3333;
            border: 1px solid #ff9999;
            box-shadow: 0 0 8px #ff3333;
        }

        @keyframes pulse-icon {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        /* --- Style for message overlays to match buttons --- */
        #message-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 4; 
            text-align: center;
            pointer-events: all;
            background: black;
            padding: 2em;
            border-radius: 5px;
            border: 2px solid var(--fragment-accent-color-ui); /* UI Color */
            box-shadow: 0 0 15px var(--fragment-accent-color-ui); /* UI Glow */
            display: none;
        }

        #message-overlay h1 {
            font-size: 3em;
            margin: 0;
            color: var(--fragment-accent-color-ui); /* UI Color */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.9), 2px 2px 3px #ff0000, 0 0 8px var(--fragment-accent-color-ui); /* UI Shadow/Glow */
            animation: pulse-title 2s infinite; /* Correct animation */
        }

        #message-overlay p {
            font-size: 1em;
            margin-bottom: 0;
            color: var(--fragment-accent-color-ui); /* UI Color */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.9), 0 0 5px var(--fragment-accent-color-ui); /* UI Shadow/Glow */
        }
        
        #touch-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 35%;
            z-index: 5; 
            display: none;
            pointer-events: none;
        }

        #joystick-area {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 150px;
            height: 150px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            pointer-events: all;
        }
        
        #joystick-knob {
            position: absolute;
            width: 70px;
            height: 70px;
            background: rgba(0, 255, 255, 0.5);
            border-radius: 50%;
            top: 40px;
            left: 40px;
        }

        #shoot-button {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 120px;
            height: 120px;
            background: rgba(255, 0, 127, 0.4);
            border: 2px solid var(--enemy-color);
            border-radius: 50%;
            pointer-events: all;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            color: var(--enemy-color);
            text-shadow: 0 0 5px var(--enemy-color);
        }
        
        @media (max-width: 800px), (max-height: 600px) {
            #main-container {
                width: 100vw;
                height: 75vw; /* 4:3 Aspect Ratio */
            }
            @media (min-aspect-ratio: 4/3) {
                 #main-container {
                    height: 100vh;
                    width: calc(100vh * 4 / 3);
                }
            }
        }

        @media (max-width: 768px) {
            #top-bar { font-size: 1em; }
            #message-overlay h1 { font-size: 2em; }
            #message-overlay p { font-size: 0.9em; }
        }
    </style>
</head>
<body>
    <div id="crt-overlay"></div>
    <div id="main-container">
        <!-- Splash Screen Elements -->
        <div id="splash-container">
            <canvas id="background-canvas"></canvas>
            <div id="click-prompt">
                <p>Click to Initiate Boot Sequence</p>
            </div>
            <div id="boot-sequence"></div>
            <h1 id="title" class="hidden-on-load">
                ECHO PROTOCOL
            </h1>
            <div id="game-info" class="hidden-on-load">
                <p>CONTROLS: WASD/Arrows to Move | SPACE to Shoot | P to Pause</p>
                <p>(Touch controls enabled on mobile)</p>
            </div>
            <button id="start-button" class="hidden-on-load">START GAME</button>
        </div>

        <!-- Main Game Elements -->
        <div id="game-container">
            <canvas id="gameCanvas"></canvas>
            <div id="ui-container">
                <div>
                    <div id="top-bar">
                        <div id="score">SCORE: 0</div>
                        <div id="lives">LIVES: 3</div>
                        <div id="fragment-status">
                            <span>FRAGS:&nbsp;</span>
                            <div id="fragment-icons"></div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Emptied the overlay, content will be generated by JS -->
            <div id="message-overlay"></div>
            <div id="touch-controls">
                <div id="joystick-area">
                    <div id="joystick-knob"></div>
                </div>
                <div id="shoot-button">SHOOT</div>
            </div>
        </div>
    </div>

    <script>
        // --- THEME COLOR MANAGEMENT ---
        const palettes = [
            { // 1. Neon Sunset
                '--glow-color': '#ff4d94',
                '--background-color': '#0d001a',
                '--enemy-color': '#00ffff',
                '--enemy-dark-color': '#008080',
                '--enemy-light-color': '#99ffff',
                '--enemy-accent-color': '#ff66ff',
            },
            { // 2. Synthwave
                '--glow-color': '#F500FF',
                '--background-color': '#20004A',
                '--enemy-color': '#FFFF00',
                '--enemy-dark-color': '#B3B300',
                '--enemy-light-color': '#FFFF99',
                '--enemy-accent-color': '#00FFFF',
            },
            { // 3. Ghost
                '--glow-color': '#ffffff',
                '--background-color': '#000000',
                '--enemy-color': '#cccccc',
                '--enemy-dark-color': '#808080',
                '--enemy-light-color': '#f2f2f2',
                '--enemy-accent-color': '#ff0000',
            },
            { // 4. Inferno
                '--glow-color': '#ff3300',
                '--background-color': '#1a0000',
                '--enemy-color': '#00e5ff',
                '--enemy-dark-color': '#007788',
                '--enemy-light-color': '#99f5ff',
                '--enemy-accent-color': '#ffcc00',
            },
            { // 5. Abyss
                '--glow-color': '#00e6ff',
                '--background-color': '#000b14',
                '--enemy-color': '#ffcc00',
                '--enemy-dark-color': '#886600',
                '--enemy-light-color': '#ffee99',
                '--enemy-accent-color': '#ff3d71',
            },
            { // 6. Solar Flare
                '--glow-color': '#ffcc00',
                '--background-color': '#330000',
                '--enemy-color': '#9933ff',
                '--enemy-dark-color': '#4d0099',
                '--enemy-light-color': '#cc99ff',
                '--enemy-accent-color': '#ffff00',
            },
            { // 7. Nebula
                '--glow-color': '#ff00ff',
                '--background-color': '#190033',
                '--enemy-color': '#00ff99',
                '--enemy-dark-color': '#00804d',
                '--enemy-light-color': '#99ffcc',
                '--enemy-accent-color': '#ff66ff',
            },
            { // 8. Acid Burn
                '--glow-color': '#bfff00',
                '--background-color': '#111900',
                '--enemy-color': '#ff00ff',
                '--enemy-dark-color': '#800080',
                '--enemy-light-color': '#ff99ff',
                '--enemy-accent-color': '#ffffff',
            },
            { // 9. Glacial
                '--glow-color': '#ffffff',
                '--background-color': '#00001a',
                '--enemy-color': '#ff6666',
                '--enemy-dark-color': '#990000',
                '--enemy-light-color': '#ffcccc',
                '--enemy-accent-color': '#99ffff',
            },
            { // 10. Matrix
                '--glow-color': '#33ff33',
                '--background-color': '#000500',
                '--enemy-color': '#ff00ff',
                '--enemy-dark-color': '#800080',
                '--enemy-light-color': '#ff99ff',
                '--enemy-accent-color': '#ffffff',
            }
        ];

        let glowColor, primaryColor, backgroundColor, enemyColor, fragmentColor, backgroundColorHex,
            playerMainColor, playerDarkColor, playerLightColor, playerAccentColor, playerCockpitColor,
            fragmentMainColor, fragmentDarkColor, fragmentLightColor, fragmentAccentColorShip, fragmentAccentColorUi,
            enemyDarkColor, enemyLightColor, enemyAccentColor;
        
        function applyTheme(palette) {
            const root = document.documentElement;
            for (const [key, value] of Object.entries(palette)) {
                root.style.setProperty(key, value);
            }
        }

        function hexToRgba(hex, alpha) {
            if (!hex) return `rgba(255, 255, 255, ${alpha})`; // Fallback for safety
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function updateThemeColors() {
            const computedStyle = getComputedStyle(document.documentElement);
            // Wave-dependent colors
            glowColor = computedStyle.getPropertyValue('--glow-color').trim();
            backgroundColorHex = computedStyle.getPropertyValue('--background-color').trim();
            enemyColor = computedStyle.getPropertyValue('--enemy-color').trim();
            enemyDarkColor = computedStyle.getPropertyValue('--enemy-dark-color').trim();
            enemyLightColor = computedStyle.getPropertyValue('--enemy-light-color').trim();
            enemyAccentColor = computedStyle.getPropertyValue('--enemy-accent-color').trim();
            
            // Constant Player colors
            playerMainColor = computedStyle.getPropertyValue('--player-main-color').trim();
            playerDarkColor = computedStyle.getPropertyValue('--player-dark-color').trim();
            playerLightColor = computedStyle.getPropertyValue('--player-light-color').trim();
            playerAccentColor = computedStyle.getPropertyValue('--player-accent-color').trim();
            playerCockpitColor = computedStyle.getPropertyValue('--player-cockpit-color').trim();

            // Constant Fragment colors
            fragmentMainColor = computedStyle.getPropertyValue('--fragment-main-color').trim();
            fragmentDarkColor = computedStyle.getPropertyValue('--fragment-dark-color').trim();
            fragmentLightColor = computedStyle.getPropertyValue('--fragment-light-color').trim();
            fragmentAccentColorShip = computedStyle.getPropertyValue('--fragment-accent-color-ship').trim();
            fragmentAccentColorUi = computedStyle.getPropertyValue('--fragment-accent-color-ui').trim();

            const r = parseInt(backgroundColorHex.slice(1, 3), 16);
            const g = parseInt(backgroundColorHex.slice(3, 5), 16);
            const b = parseInt(backgroundColorHex.slice(5, 7), 16);
            backgroundColor = `rgb(${r}, ${g}, ${b})`;
        }

        // --- Global Audio Variables ---
        let audioInitialized = false;
        let bassPulse, choirSynth, shootSynth, explosionSynth, alarmSynth, decodedMessageSynth, waveCompleteSynth, bootKeySynth, extraLifeSynth, gameOverSynth, startGameSynth, keyClatterLoop, fragmentDestroyedSynth, rescueBonusSynth, playerCollisionSynth;
        const fragmentScale = ['C3', 'Eb3', 'G3', 'Bb3', 'C4', 'Eb4', 'G4', 'Bb4'];

        // --- Single, comprehensive audio initialization function ---
        function initAllAudio() {
            if (audioInitialized) return;
            try {
                // Game Synths
                bassPulse = new Tone.PulseOscillator('C1', 0.5).toDestination();
                const bassLFO = new Tone.LFO("4n", 0.5, 1).connect(bassPulse.width);
                bassLFO.start();
                bassPulse.volume.value = -32;
                
                choirSynth = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: 'fatsawtooth', count: 3, spread: 30 },
                    envelope: { attack: 1, decay: 0.1, sustain: 1, release: 2 },
                    volume: -25
                }).toDestination();

                shootSynth = new Tone.PolySynth(Tone.FMSynth, {
                    harmonicity: 1.5,
                    modulationIndex: 8,
                    oscillator: { type: 'sawtooth' },
                    envelope: {
                        attack: 0.01,
                        decay: 0.15,
                        sustain: 0.01,
                        release: 0.1
                    },
                    modulation: { type: 'sine' },
                    modulationEnvelope: {
                        attack: 0.01,
                        decay: 0.05,
                        sustain: 0,
                        release: 0.1
                    },
                    volume: -12
                }).toDestination();

                explosionSynth = new Tone.PolySynth(Tone.NoiseSynth, {
                    noise: { type: 'white' },
                    envelope: { attack: 0.005, decay: 0.1, sustain: 0 },
                    volume: -10
                }).toDestination();
                
                fragmentDestroyedSynth = new Tone.PolySynth(Tone.FMSynth, {
                    harmonicity: 0.8,
                    modulationIndex: 15,
                    envelope: { attack: 0.01, decay: 0.5, sustain: 0 },
                    volume: -10
                }).toDestination();

                rescueBonusSynth = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: 'triangle' },
                    envelope: { attack: 0.01, decay: 0.4, sustain: 0.1, release: 0.2 },
                    volume: -8
                }).toDestination();

                // Splash Screen Synths
                alarmSynth = new Tone.MonoSynth({
                    oscillator: { type: 'square' },
                    envelope: { attack: 0.1, decay: 0.2, sustain: 0.1, release: 0.5 },
                    volume: -12
                }).toDestination();

                waveCompleteSynth = new Tone.FMSynth({
                    harmonicity: 1.5,
                    modulationIndex: 8,
                    envelope: { attack: 0.2, decay: 1 },
                    volume: -12
                }).toDestination();

                decodedMessageSynth = new Tone.FMSynth({
                    harmonicity: 3,
                    modulationIndex: 10,
                    envelope: { attack: 0.01, decay: 0.2 },
                    volume: -9
                }).toDestination();
                
                const keyClatterSynth = new Tone.NoiseSynth({
                    noise: { type: 'brown' }, 
                    envelope: { attack: 0.001, decay: 0.05, sustain: 0 },
                    volume: -22
                }).toDestination();

                const keyClatterFilter = new Tone.Filter(1500, "bandpass").toDestination(); 
                keyClatterFilter.Q.value = 1.5; 
                keyClatterSynth.connect(keyClatterFilter);
                
                keyClatterLoop = new Tone.Sequence((time, note) => {
                    if (note) { 
                        keyClatterFilter.frequency.setValueAtTime(Math.random() * 2000 + 1000, time);
                        keyClatterSynth.volume.setValueAtTime(Math.random() * 5 - 22, time);
                        keyClatterSynth.triggerAttack(time);
                    }
                }, ['C4', 'C4', null, 'C4', 'C4'], "16n").start(0);

                keyClatterLoop.humanize = true;

                extraLifeSynth = new Tone.PolySynth(Tone.FMSynth, {
                    harmonicity: 1.2,
                    modulationIndex: 10,
                    envelope: { attack: 0.01, decay: 0.3, sustain: 0.1, release: 0.7 },
                    volume: -5
                }).toDestination();

                gameOverSynth = new Tone.PolySynth(Tone.FMSynth, {
                    harmonicity: 1.2,
                    modulationIndex: 10,
                    envelope: { attack: 0.01, decay: 0.5, sustain: 0.1, release: 1 },
                    volume: -2
                }).toDestination();

                playerCollisionSynth = new Tone.PolySynth(Tone.FMSynth, {
                    harmonicity: 0.8,
                    modulationIndex: 15,
                    envelope: { attack: 0.01, decay: 0.5, sustain: 0 },
                    volume: -10
                }).toDestination();

                startGameSynth = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: 'triangle' },
                    envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 },
                    volume: -11
                }).toDestination();

                audioInitialized = true;
            } catch (e) {
                console.error("Audio initialization failed:", e);
                audioInitialized = false;
            }
        }


        // --- SPLASH SCREEN LOGIC ---
        const lines = [
            '> INITIATING ECHO_PROTOCOL.EXE',
            '> LOADING RENDERER... OK',
            '> CALIBRATING GRID... OK',
            '> HINT: PERFECT RUN ENABLED...',
            '> WARNING: DATA STORM DETECTED...',
            '> BOOT SEQUENCE COMPLETE.'
        ];

        let lineIndex = 0;
        function typeLine() {
            if (lineIndex < lines.length) {
                const lineEl = document.createElement('div');
                lineEl.className = 'line';
                lineEl.textContent = lines[lineIndex];
                document.getElementById('boot-sequence').appendChild(lineEl);

                lineIndex++;
                setTimeout(typeLine, 450);
            }
        }
        
        // --- VANILLA JS CANVAS BACKGROUND ---
        let bgAnimationId;
        function initCanvasBackground() {
            const backgroundCanvas = document.getElementById('background-canvas');
            const bgCtx = backgroundCanvas.getContext('2d');
            let fov, cameraZ, cameraY, centerX, centerY;
            const scrollSpeed = 0.5;
            const starSpeed = 0.1;
            const mountainSpeed = 0.2;
            let stars = [], gridPoints = [], mountains = [];

            backgroundCanvas.width = 800;
            backgroundCanvas.height = 600;
            fov = backgroundCanvas.width * 0.8;
            cameraZ = -5;
            cameraY = 25;
            centerX = backgroundCanvas.width / 2;
            centerY = backgroundCanvas.height / 2;
            stars = [];
            for (let i = 0; i < 500; i++) {
                stars.push({ x: Math.random() * 400 - 200, y: Math.random() * 200 - 100, z: Math.random() * 400 });
            }
            gridPoints = [];
            const gridSize = 30, gridDepth = 30, step = 10;
            for (let z = 0; z < gridDepth; z++) {
                for (let x = 0; x < gridSize; x++) {
                    gridPoints.push({ x: (x - gridSize / 2) * step, y: 50, z: z * step });
                }
            }
            mountains = [];
            const mountainRanges = 2, mountainSegments = 50, mountainWidth = 800;
            for (let i = 0; i < mountainRanges; i++) {
                const range = [];
                const roughness = 5 + i * 5, amplitude = 20 + i * 20, zPos = 150 + i * 80;
                for (let j = 0; j <= mountainSegments; j++) {
                    range.push({ x: (j / mountainSegments - 0.5) * mountainWidth, y: 40 - Math.random() * amplitude, z: zPos + (Math.random() - 0.5) * roughness, offsetZ: 0 });
                }
                mountains.push(range);
            }
            
            function project(p) {
                const z = p.z - cameraZ;
                if (z <= 0) return null;
                const scale = fov / z;
                const x2d = centerX + p.x * scale;
                const y2d = centerY + (p.y - cameraY) * scale;
                return { x: x2d, y: y2d, scale: scale };
            }

            function animateCanvasBackground() {
                bgAnimationId = requestAnimationFrame(animateCanvasBackground);
                bgCtx.fillStyle = backgroundColor;
                bgCtx.fillRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
                bgCtx.fillStyle = 'rgba(0, 255, 255, 0.8)';
                stars.forEach(star => {
                    star.z -= starSpeed;
                    if (star.z < cameraZ) star.z = 400;
                    const p = project(star);
                    if (p) bgCtx.fillRect(p.x, p.y, p.scale * 1.5, p.scale * 1.5);
                });
                bgCtx.strokeStyle = hexToRgba(glowColor, 0.3);
                bgCtx.lineWidth = 1;
                mountains.forEach((range, index) => {
                    range.forEach(p => { p.offsetZ = (p.offsetZ - mountainSpeed * (index + 1)) % 200; });
                    bgCtx.beginPath();
                    let firstPoint = true;
                    for (let i = 0; i < range.length; i++) {
                        const p3d = { x: range[i].x, y: range[i].y, z: range[i].z + range[i].offsetZ };
                        const p2d = project(p3d);
                        if (p2d) {
                            if (firstPoint) { bgCtx.moveTo(p2d.x, p2d.y); firstPoint = false; } 
                            else { bgCtx.lineTo(p2d.x, p2d.y); }
                        }
                    }
                    bgCtx.stroke();
                });
                const horizonY = centerY;
                bgCtx.fillStyle = hexToRgba(backgroundColorHex, 0.9);
                bgCtx.fillRect(0, horizonY, backgroundCanvas.width, backgroundCanvas.height - horizonY);
                bgCtx.strokeStyle = 'rgba(255, 0, 255, 0.2)';
                bgCtx.lineWidth = 0.5;
                gridPoints.forEach(p => {
                    p.z -= scrollSpeed;
                    if (p.z < cameraZ) p.z += 300;
                });
                const gridSize = 30;
                for (let z = 0; z < 29; z++) {
                    for (let x = 0; x < 29; x++) {
                        const p1 = project(gridPoints[z * gridSize + x]);
                        const p2 = project(gridPoints[z * gridSize + x + 1]);
                        const p3 = project(gridPoints[(z + 1) * gridSize + x]);
                        if (p1 && p2) { bgCtx.beginPath(); bgCtx.moveTo(p1.x, p1.y); bgCtx.lineTo(p2.x, p2.y); bgCtx.stroke(); }
                        if (p1 && p3) { bgCtx.beginPath(); bgCtx.moveTo(p1.x, p1.y); bgCtx.lineTo(p3.x, p3.y); bgCtx.stroke(); }
                    }
                }
            }
            if(bgAnimationId) cancelAnimationFrame(bgAnimationId);
            animateCanvasBackground();
        }

        function playTitleSoundSequence() {
            if (!audioInitialized) return;
            const now = Tone.now();
            fragmentScale.forEach((note, index) => {
                decodedMessageSynth.triggerAttackRelease(note, '16n', now + index * 0.12);
            });
        }

        // --- MAIN GAME LOGIC (WRAPPED IN A FUNCTION) ---
        function launchGame() {
            const splashContainer = document.getElementById('splash-container');
            const gameContainer = document.getElementById('game-container');
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const scoreEl = document.getElementById('score');
            const livesEl = document.getElementById('lives');
            const fragmentIconsEl = document.getElementById('fragment-icons');
            const messageOverlay = document.getElementById('message-overlay');
            const touchControls = document.getElementById('touch-controls');
            const joystickArea = document.getElementById('joystick-area');
            const joystickKnob = document.getElementById('joystick-knob');
            const shootButton = document.getElementById('shoot-button');
            const uiContainer = document.getElementById('ui-container');

            cancelAnimationFrame(bgAnimationId);
            splashContainer.style.display = 'none';
            gameContainer.style.display = 'block';

            let width, height;
            let gameState = 'start';
            let score = 0;
            const initialLives = 3;
            let lives = initialLives;
            let wave = 1;
            let nextLifeScore = 100000;
            let fragmentsRescued = 0, fragmentsLost = 0, totalFragments = 8, fragmentSpawnTimer = 0;
            let waveFragmentScore = 0; 
            let perfectRun = true;
            let lastTime = 0;
            let animationFrameId;
            let player, landscape, dataStorm, uplinkZone;
            let bullets = [], enemies = [], fragments = [], particles = [], fragmentManifest = [], fragmentIconEls = [];
            const keys = {};
            let isShooting = false, joystickActive = false;
            let joystickStart = { x: 0, y: 0 }, joystickCurrent = { x: 0, y: 0 };
            let activeChoirNotes = [];
            let alarmCooldown = 0;

            class Player {
                constructor() {
                    this.x = width / 4;
                    this.y = height / 2;
                    this.width = 30;
                    this.height = 21;
                    this.speed = 5;
                    this.vx = 0;
                    this.vy = 0;
                    this.friction = 0.9;
                    this.trail = [];
                    this.shootCooldown = 0;
                    this.maxFollowing = 4;
                    this.isInvincible = false;
                    this.invincibilityTimer = 0;
                    this.invincibilityDuration = 180;
                }
                update() {
                    if (this.isInvincible) { this.invincibilityTimer--; if (this.invincibilityTimer <= 0) this.isInvincible = false; }
                    let moveX = 0, moveY = 0;
                    if (keys['w'] || keys['arrowup']) moveY = -1;
                    if (keys['s'] || keys['arrowdown']) moveY = 1;
                    if (keys['a'] || keys['arrowleft']) moveX = -1;
                    if (keys['d'] || keys['arrowright']) moveX = 1;
                    if (joystickActive) { const dx = joystickCurrent.x - joystickStart.x, dy = joystickCurrent.y - joystickStart.y; if (Math.sqrt(dx*dx + dy*dy) > 10) { moveX = dx / 50; moveY = dy / 50; } }
                    this.vx += moveX * 0.5; this.vy += moveY * 0.5; this.vx *= this.friction; this.vy *= this.friction;
                    this.x += this.vx; this.y += this.vy;
                    if (this.x < this.width / 2) this.x = this.width / 2; if (this.x > width - this.width / 2) this.x = width - this.width / 2; if (this.y < this.height / 2) this.y = this.height / 2; if (this.y > height - this.height / 2) this.y = height - this.height / 2;
                    this.trail.push({ x: this.x, y: this.y }); if (this.trail.length > 20) this.trail.shift();
                    if (this.shootCooldown > 0) this.shootCooldown--; if (isShooting && this.shootCooldown === 0) { this.shoot(); this.shootCooldown = 10; }
                    if(audioInitialized) { const velocityMagnitude = Math.sqrt(this.vx * this.vx + this.vy * this.vy); bassPulse.volume.value = Tone.gainToDb((velocityMagnitude / 15) * 0.175); }
                }
                shoot() {
                    bullets.push(new Bullet(this.x + this.width / 2, this.y));
                    if(audioInitialized) {
                        const now = Tone.now();
                        const voice = shootSynth.triggerAttack("C4", now);
                        if (voice && voice.detune) {
                            voice.detune.setValueAtTime(-1200, now);
                            voice.detune.rampTo(0, 0.1, now);
                        }
                        shootSynth.triggerRelease("C4", now + 0.1);
                    }
                }
                
                draw() {
                    if (this.isInvincible && Math.floor(this.invincibilityTimer / 6) % 2 === 0) return;
                    
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    const p = 1.5; 
                    
                    ctx.shadowColor = glowColor;
                    ctx.shadowBlur = 10;
                    
                    ctx.fillStyle = playerDarkColor;
                    ctx.fillRect(-p * 10, -p * 2, p * 4, p * 4);
                    ctx.fillRect(-p * 8, -p * 3, p * 2, p * 6); 

                    ctx.fillStyle = playerMainColor;
                    ctx.fillRect(-p * 6, -p * 1.5, p * 12, p * 3);
                    
                    ctx.fillStyle = playerCockpitColor;
                    ctx.fillRect(-p * 4, -p * 5, p * 9, p * 2); 
                    ctx.fillRect(-p * 4, p * 3, p * 9, p * 2); 
                    ctx.fillStyle = playerMainColor;
                    ctx.fillRect(-p * 5, -p * 3, p * 10, p * 1); 
                    ctx.fillRect(-p * 5, p * 2, p * 10, p * 1);

                    ctx.fillStyle = playerLightColor;
                    ctx.fillRect(p * 6, -p * 1, p * 2, p * 2);
                    ctx.fillStyle = playerAccentColor;
                    ctx.fillRect(p * 8, -p * 0.5, p * 2, p * 1);

                    ctx.shadowBlur = 0;
                    ctx.restore();
                }
            }
            class Bullet {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                    this.width = 12;
                    this.height = 4;
                    this.speed = 10;
                }
                update() { this.x += this.speed; }
                draw() { 
                    ctx.fillStyle = '#ffae42';
                    ctx.shadowColor = '#ffae42'; 
                    ctx.shadowBlur = 10; 
                    ctx.fillRect(this.x, this.y - this.height / 2, this.width, this.height); 
                    ctx.shadowBlur = 0; 
                }
            }
            class Fragment {
                constructor(x, y, index) {
                    this.x = x;
                    this.y = y;
                    this.size = 24;
                    this.state = 'in_play';
                    this.target = null;
                    this.index = index;
                    this.speedX = -1;
                    this.pulseTimer = Math.random() * Math.PI * 2;
                }
                update() {
                    if (this.state === 'in_play') {
                        this.x += this.speedX;
                        this.pulseTimer += 0.1;
                        if (this.x < -this.size) {
                            this.state = 'lost';
                        }
                    } else if (this.state === 'following') {
                        if (!this.target) {
                            this.state = 'in_play';
                            fragmentManifest[this.index].status = 'in_play';
                            return;
                        }
                        const targetX = this.target.x - 60 - (fragments.filter(f => f.state === 'following').indexOf(this) * 25);
                        const targetY = this.target.y;
                        const dx = targetX - this.x;
                        const dy = targetY - this.y;
                        this.x += dx * 0.08;
                        this.y += dy * 0.08;
                        
                        if (this.x < 20) {
                            this.state = 'rescued';
                        }
                    }
                }
                
                draw() {
                    if (this.state === 'following' && player) {
                        ctx.beginPath();
                        ctx.moveTo(player.x, player.y);
                        const midX = (player.x + this.x) / 2;
                        const midY = (player.y + this.y) / 2;
                        const controlY = midY + 40;
                        ctx.quadraticCurveTo(midX, controlY, this.x, this.y);
                        ctx.strokeStyle = hexToRgba(fragmentMainColor, 0.6);
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                    
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    if (this.state === 'in_play') {
                        const scale = 1 + Math.sin(this.pulseTimer) * 0.3;
                        ctx.scale(scale, scale);
                    }

                    const p = 1.5;
                    
                    ctx.shadowColor = fragmentMainColor;
                    ctx.shadowBlur = 15;

                    ctx.fillStyle = fragmentMainColor;
                    ctx.fillRect(-p * 2, -p * 2, p * 4, p * 4);
                    ctx.fillRect(-p * 1, -p * 3, p * 2, p * 6);
                    ctx.fillRect(p * 1, -p * 4, p * 1, p * 8);
                    ctx.fillRect(p * 2, -p * 5, p * 2, p * 10);

                    ctx.fillStyle = fragmentDarkColor;
                    ctx.fillRect(-p * 4, -p * 2, p * 2, p * 4);
                    ctx.fillRect(-p * 6, -p * 1, p * 2, p * 2);
                    
                    ctx.fillStyle = fragmentLightColor;
                    ctx.fillRect(-p * 5, -p * 3, p * 1, p * 6);
                    ctx.fillRect(-p * 3, -p * 4, p * 1, p * 8);
                    
                    ctx.fillStyle = fragmentAccentColorShip;
                    ctx.fillRect(p * 4, -p * 2, p * 1, p * 4);
                    ctx.fillRect(p * 2, -p * 6, p * 1, p * 1);
                    ctx.fillRect(p * 2, p * 5, p * 1, p * 1);
                    ctx.fillRect(p * 3, -p * 1, p * 1, p * 2);

                    ctx.shadowBlur = 0;
                    ctx.restore();
                }
            }
            class Enemy { 
                constructor(wave) {
                    this.x = width + 50;
                    this.y = Math.random() * height;
                    this.width = 30;
                    this.height = 24;
                    this.speedX = - (2 + Math.random() * 2 + wave * 0.3);
                    this.speedY = (Math.random() - 0.5) * 2;
                    this.type = (Math.random() < (0.15 + wave * 0.04)) ? 'seeker' : 'drifter';
                    this.pulseTimer = Math.random() * Math.PI * 2;
                }
                update() {
                    if (this.type === 'seeker' && player) {
                        const dy = player.y - this.y;
                        this.speedY = dy * 0.015;
                    }
                    this.x += this.speedX;
                    this.y += this.speedY;
                    this.pulseTimer += 0.1;
                } 
                
                draw() {
                    ctx.save();
                    ctx.translate(this.x, this.y);

                    if (this.type === 'seeker') {
                        const scale = 1 + Math.sin(this.pulseTimer) * 0.3;
                        ctx.scale(scale, scale);
                    }
                    
                    const p = 1.5;
                    
                    ctx.shadowColor = enemyColor;
                    ctx.shadowBlur = 15;
                    
                    ctx.fillStyle = enemyDarkColor;
                    ctx.fillRect(-p * 10, -p * 3, p * 5, p * 6);
                    
                    ctx.fillStyle = enemyColor;
                    ctx.fillRect(-p * 6, -p * 2, p * 10, p * 4);
                    ctx.fillRect(-p * 4, -p * 4, p * 4, p * 8); 
                    
                    ctx.fillStyle = enemyLightColor;
                    ctx.fillRect(p * 4, -p * 5, p * 2, p * 2); 
                    ctx.fillRect(p * 4, p * 3, p * 2, p * 2); 
                    ctx.fillRect(p * 6, -p * 4, p * 2, p * 1); 
                    ctx.fillRect(p * 6, p * 3, p * 2, p * 1);

                    ctx.fillStyle = enemyAccentColor;
                    ctx.fillRect(p * 2, -p * 1, p * 3, p * 2);
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                }
            }
            
            class Particle {
                constructor(x, y, color) {
                    this.x = x;
                    this.y = y;
                    this.initialSize = Math.random() * 4 + 2;
                    this.size = this.initialSize;
                    this.vx = (Math.random() - 0.5) * 2.5;
                    this.vy = (Math.random() - 0.5) * 2.5;
                    this.life = 1;
                    this.color = color;
                }
                update() {
                    this.x += this.vx;
                    this.y += this.vy;
                    this.life -= 0.015;
                    this.size = this.initialSize * this.life;
                }
                draw() {
                    if (this.life <= 0 || this.size <= 0) return;
                    ctx.save();
                    ctx.globalAlpha = this.life;
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);
                    ctx.restore();
                }
            }

            class WireframeLandscape {
                constructor() {
                    this.points = [];
                    this.scrollSpeed = 0.5;
                    this.generatePoints();
                }
                generatePoints() {
                    this.points = [];
                    for (let i = 0; i < width * 2 / 50 + 2; i++) {
                        this.points.push({
                            x: i * 50,
                            y1: height - (Math.random() * height / 4),
                            y2: height - (Math.random() * height / 8),
                        });
                    }
                }
                update() {
                    this.points.forEach(p => p.x -= this.scrollSpeed);
                    if (this.points.length > 0 && this.points[0].x < -50) {
                        this.points.shift();
                        this.points.push({
                            x: this.points[this.points.length - 1].x + 50,
                            y1: height - (Math.random() * height / 4),
                            y2: height - (Math.random() * height / 8),
                        });
                    }
                }
                draw(targetCtx) { // Accept a context to draw on
                    targetCtx.strokeStyle = hexToRgba(glowColor, 0.3);
                    targetCtx.lineWidth = 1;
                    targetCtx.shadowColor = glowColor;
                    targetCtx.shadowBlur = 10;
                    if (this.points.length > 0) {
                        targetCtx.beginPath();
                        targetCtx.moveTo(this.points[0].x, this.points[0].y2);
                        for (let i = 1; i < this.points.length; i++) targetCtx.lineTo(this.points[i].x, this.points[i].y2);
                        targetCtx.stroke();
                        targetCtx.beginPath();
                        targetCtx.moveTo(this.points[0].x, this.points[0].y1);
                        for (let i = 1; i < this.points.length; i++) targetCtx.lineTo(this.points[i].x, this.points[i].y1);
                        targetCtx.stroke();
                        targetCtx.beginPath();
                        for (let i = 0; i < this.points.length; i++) {
                            targetCtx.moveTo(this.points[i].x, this.points[i].y1);
                            targetCtx.lineTo(this.points[i].x, height);
                        }
                        for (let y = height; y > height * 0.6; y -= 20) {
                            targetCtx.moveTo(0, y);
                            targetCtx.lineTo(width, y);
                        }
                        targetCtx.strokeStyle = hexToRgba(glowColor, 0.1);
                        targetCtx.stroke();
                    }
                    targetCtx.shadowBlur = 0;
                }
            }
            class DataStorm {
                constructor() {
                    this.particles = [];
                    for (let i = 0; i < 100; i++) {
                        this.particles.push({
                            x: Math.random() * width,
                            y: Math.random() * height,
                            z: Math.random() * width,
                            size: 2
                        });
                    }
                }
                update() {
                    this.particles.forEach(p => {
                        p.z -= 1;
                        if (p.z <= 0) {
                            p.z = width;
                            p.x = Math.random() * width;
                            p.y = Math.random() * height;
                        }
                    });
                }
                draw(targetCtx) { // Accept a context to draw on
                    targetCtx.fillStyle = hexToRgba(playerMainColor, 0.5);
                    this.particles.forEach(p => {
                        const scale = width / (width + p.z);
                        const x2d = (p.x - width / 2) * scale + width / 2;
                        const y2d = (p.y - height / 2) * scale + height / 2;
                        const size = scale * p.size;
                        targetCtx.fillRect(x2d, y2d, size, size);
                    });
                }
            }
             class DataUplinkZone {
                constructor() {
                    this.width = 50;
                    this.flashTimer = 0;
                    this.flashColor = null;
                }
                update() {
                    if (this.flashTimer > 0) this.flashTimer--;
                }
                triggerFlash(color = null) {
                    this.flashTimer = 15; // Flash for 1/4 second (15 frames at 60fps)
                    this.flashColor = color;
                }
                draw() {
                    ctx.save();
                    // Draw grid
                    ctx.strokeStyle = hexToRgba(glowColor, 0.2);
                    ctx.lineWidth = 0.5;
                    for (let x = 0; x < this.width; x += 20) {
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, height);
                        ctx.stroke();
                    }
                    for (let y = height; y > 0; y -= 20) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(this.width, y);
                        ctx.stroke();
                    }

                    // Draw text
                    let textColor = hexToRgba(glowColor, 0.3);
                    if (this.flashTimer > 0) {
                        if (this.flashColor === 'white') {
                            textColor = 'rgba(255, 255, 255, 0.9)';
                        } else if (this.flashColor === 'gold') {
                            textColor = hexToRgba(fragmentAccentColorUi, 0.9);
                        } else {
                            textColor = hexToRgba(glowColor, 0.7);
                        }
                    }

                    ctx.fillStyle = textColor;
                    ctx.font = "36px 'VT323', monospace";
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    ctx.save();
                    ctx.translate(this.width / 2, height / 2);
                    ctx.rotate(-Math.PI / 2);
                    ctx.fillText('<< FRAGMENT UPLINK >>', 0, 0);
                    ctx.restore();
                    
                    ctx.restore();
                }
            }

            function startWave(waveNumber) {
                gameState = 'wave_end'; 
                wave = waveNumber;
                player = null; 
                
                enemies = [];
                bullets = [];
                particles = [];
                fragments = [];

                const perfectBonus = perfectRun ? 5000 : 0;
                score += perfectBonus;
                
                messageOverlay.innerHTML = '';
                const title = document.createElement('h1');
                const subtext = document.createElement('p');

                title.textContent = `WAVE ${wave - 1} COMPLETE`;
                let bonusText = `Fragment Bonus: ${waveFragmentScore}`; if (perfectRun) bonusText += ` | PERFECT: ${perfectBonus}`;
                subtext.innerHTML = bonusText;
                
                messageOverlay.appendChild(title);
                messageOverlay.appendChild(subtext);
                messageOverlay.style.display = 'block';

                if(audioInitialized) waveCompleteSynth.triggerAttackRelease("C3", "2s");
                
                setTimeout(() => {
                    const themeIndex = (waveNumber - 1) % palettes.length;
                    applyTheme(palettes[themeIndex]);
                    updateThemeColors();

                    fragmentsRescued = 0; 
                    fragmentsLost = 0; 
                    waveFragmentScore = 0;
                    perfectRun = true; 
                    fragmentSpawnTimer = 3;
                    
                    fragmentManifest = [];
                    for(let i = 0; i < totalFragments; i++) {
                        fragmentManifest.push({ id: i, status: 'unspawned' });
                    }
                    
                    if(audioInitialized) choirSynth.releaseAll(); 
                    activeChoirNotes = [];
                    
                    messageOverlay.innerHTML = '';
                    title.textContent = `WAVE ${wave}`;
                    subtext.textContent = 'Get Ready...';
                    messageOverlay.appendChild(title);
                    messageOverlay.appendChild(subtext);

                    setTimeout(() => { 
                        player = new Player(); 
                        messageOverlay.style.display = 'none'; 
                        gameState = 'playing'; 
                    }, 2000);
                }, 4000);
            }

            function setupFragmentUI() {
                fragmentIconsEl.innerHTML = '';
                fragmentIconEls = [];
                for(let i = 0; i < totalFragments; i++) {
                    const icon = document.createElement('div');
                    icon.className = 'fragment-icon';
                    fragmentIconsEl.appendChild(icon);
                    fragmentIconEls.push(icon);
                }
            }

            function updateFragmentStatusUI() {
                for(let i = 0; i < fragmentManifest.length; i++) {
                    fragmentIconEls[i].className = `fragment-icon ${fragmentManifest[i].status}`;
                }
            }

            function startGame() {
                if(audioInitialized) {
                    const now = Tone.now();
                    const notes = ['C4', 'E4', 'G4', 'C5'];
                    notes.forEach((note, i) => {
                        startGameSynth.triggerAttackRelease(note, '16n', now + i * 0.07);
                    });
                }
                applyTheme(palettes[0]);
                updateThemeColors();
                if(audioInitialized) bassPulse.start();
                
                uiContainer.style.display = 'flex';

                score = 0; lives = initialLives; wave = 1; nextLifeScore = 100000;
                fragmentsRescued = 0; fragmentsLost = 0; waveFragmentScore = 0;
                perfectRun = true; 
                fragmentSpawnTimer = 3; // Initial delay
                
                fragmentManifest = [];
                for(let i = 0; i < totalFragments; i++) {
                    fragmentManifest.push({ id: i, status: 'unspawned' });
                }
                
                player = new Player(); bullets = []; enemies = []; particles = []; fragments = [];
                landscape = new WireframeLandscape(); dataStorm = new DataStorm(); uplinkZone = new DataUplinkZone();
                
                setupFragmentUI();

                messageOverlay.style.display = 'none'; gameState = 'playing';
                lastTime = performance.now();
                if(animationFrameId) cancelAnimationFrame(animationFrameId);
                animate(lastTime);
            }

            function loseLife() {
                if (!player || player.isInvincible) return;
                lives--;
                for (let i = 0; i < 20; i++) particles.push(new Particle(player.x, player.y, playerMainColor));
                if(audioInitialized) playerCollisionSynth.triggerAttackRelease(['G3','D3','A2'], "16n", Tone.now());
                if (lives < 0) {
                    endGame('lose');
                } else { 
                    player.isInvincible = true; 
                    player.invincibilityTimer = player.invincibilityDuration; 
                    player.x = width / 4; 
                    player.y = height / 2; 
                    player.vx = 0; 
                    player.vy = 0; 
                }
            }

            function togglePause() {
                if (gameState === 'playing') {
                    gameState = 'paused';
                    if(audioInitialized) Tone.Destination.mute = true;
                    
                    messageOverlay.innerHTML = '<h1>PAUSED</h1>';
                    messageOverlay.style.display = 'block';

                } else if (gameState === 'paused') {
                    gameState = 'playing';
                    if(audioInitialized) Tone.Destination.mute = false;

                    messageOverlay.style.display = 'none';
                    lastTime = performance.now();
                }
            }

            function update(dt) {
                if (gameState !== 'playing' || !player) return;
                
                if (alarmCooldown > 0) alarmCooldown--;

                player.update(); 
                landscape.update(); 
                dataStorm.update();
                uplinkZone.update();

                bullets = bullets.filter(b => b.x < width); 
                bullets.forEach(b => b.update());

                const enemyCount = 5 + wave * 2; 
                if (Math.random() < (0.02 + wave * 0.002) && enemies.length < enemyCount) {
                    enemies.push(new Enemy(wave));
                }
                enemies = enemies.filter(e => e.x > -e.width); 
                
                let seekerOnScreen = false;
                enemies.forEach(e => {
                    e.update();
                    if (e.type === 'seeker') {
                        seekerOnScreen = true;
                    }
                });

                if (seekerOnScreen && audioInitialized && alarmCooldown === 0) {
                    alarmSynth.triggerAttackRelease("G5", "16n", Tone.now());
                    alarmCooldown = 60; 
                }

                fragmentSpawnTimer -= dt;
                const spawnedFragments = fragmentManifest.filter(f => f.status !== 'unspawned').length;
                if (fragmentSpawnTimer <= 0 && spawnedFragments < totalFragments) {
                    const nextFragmentIndex = fragmentManifest.findIndex(f => f.status === 'unspawned');
                    if(nextFragmentIndex !== -1) {
                        fragments.push(new Fragment(width + 20, Math.random() * height, nextFragmentIndex)); 
                        fragmentManifest[nextFragmentIndex].status = 'in_play';
                        fragmentSpawnTimer = Math.max(3, 15 - wave * 0.75); // Reset timer
                    }
                }
                
                fragments.forEach(f => f.update());
                
                const justRescuedFragments = fragments.filter(f => f.state === 'rescued');
                if (justRescuedFragments.length > 0) {
                    const followingCount = fragments.filter(f => f.state === 'following').length;
                    const totalInGroup = followingCount + justRescuedFragments.length;

                    if (totalInGroup === 4) {
                        if (audioInitialized) {
                            rescueBonusSynth.triggerAttackRelease(['C4', 'E4', 'G4', 'C5'], '8n', Tone.now());
                        }
                        uplinkZone.triggerFlash('gold');
                    } else {
                        uplinkZone.triggerFlash();
                    }

                    justRescuedFragments.forEach(fragment => {
                        const points = 1000 * totalInGroup;
                        score += points;
                        waveFragmentScore += points;
                        fragmentsRescued++;
                        fragmentManifest[fragment.index].status = 'rescued';

                        if (audioInitialized) {
                            const note = fragmentScale[fragment.index % fragmentScale.length];
                            choirSynth.triggerAttack(note);
                            activeChoirNotes.push(note);
                        }
                    });
                    
                    fragments = fragments.filter(f => f.state !== 'rescued');
                }
                
                const justLostFragments = fragments.filter(f => f.state === 'lost');
                if (justLostFragments.length > 0) {
                    justLostFragments.forEach(fragment => {
                        fragmentsLost++;
                        perfectRun = false;
                        fragmentManifest[fragment.index].status = 'lost';
                    });
                    fragments = fragments.filter(f => f.state !== 'lost');
                }


                particles = particles.filter(p => p.life > 0); 
                particles.forEach(p => p.update());
                
                bullets.forEach((bullet, bIndex) => { 
                    enemies.forEach((enemy, eIndex) => { 
                        if (!bullet) return;
                        const ex = enemy.x - enemy.width / 2;
                        const ey = enemy.y - enemy.height / 2;
                        if (bullet.x < ex + enemy.width && bullet.x + bullet.width > ex && bullet.y < ey + enemy.height && bullet.y + bullet.height > ey) {
                            for (let i = 0; i < 15; i++) particles.push(new Particle(enemy.x, enemy.y, enemyColor));
                            if(audioInitialized) explosionSynth.triggerAttackRelease("8n"); 
                            enemies.splice(eIndex, 1); 
                            bullets.splice(bIndex, 1); 
                            score += 100; 
                        } 
                    }); 
                });
                
                fragments.forEach(fragment => {
                    if (!player) return;
                    if (fragment.state === 'in_play') {
                        const dx = player.x - fragment.x;
                        const dy = player.y - fragment.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const followingCount = fragments.filter(f => f.state === 'following').length;
                        if (dist < 60 && followingCount < player.maxFollowing) {
                            fragment.state = 'following';
                            fragmentManifest[fragment.index].status = 'following';
                            fragment.target = player;
                        }
                    }
                });
                
                enemies.forEach(enemy => { 
                    if (!player || player.isInvincible) return;
                    const px = player.x - player.width / 2;
                    const py = player.y - player.height / 2;
                    const ex = enemy.x - enemy.width / 2;
                    const ey = enemy.y - enemy.height / 2;
                    if (px < ex + enemy.width && px + player.width > ex && py < ey + enemy.height && py + player.height > ey) {
                        loseLife();
                    }
                });

                enemies.forEach(enemy => { 
                    fragments.forEach((fragment, fIndex) => { 
                        if (fragment.state === 'following') {
                            const ex = enemy.x - enemy.width / 2;
                            const ey = enemy.y - enemy.height / 2;
                            const fx = fragment.x - fragment.size / 2;
                            const fy = fragment.y - fragment.size / 2;
                            if (ex < fx + fragment.size && ex + enemy.width > fx && ey < fy + fragment.size && ey + enemy.height > fy) {
                                for (let i = 0; i < 10; i++) particles.push(new Particle(fragment.x, fragment.y, fragmentMainColor)); 
                                if(audioInitialized) {
                                    fragmentDestroyedSynth.triggerAttackRelease(['C5', 'A4', 'F#4', 'C4'], '8n', Tone.now());
                                    const note = fragmentScale[fragment.index % fragmentScale.length]; 
                                    choirSynth.triggerRelease(note); 
                                    activeChoirNotes = activeChoirNotes.filter(n => n !== note); 
                                } 
                                fragmentManifest[fragment.index].status = 'lost';
                                fragments.splice(fIndex, 1); 
                                perfectRun = false; 
                                fragmentsLost++; 
                            } 
                        } 
                    }); 
                });

                if (fragmentsRescued + fragmentsLost >= totalFragments) startWave(wave + 1);
                
                if (score >= nextLifeScore) {
                    lives++;
                    nextLifeScore += 100000;
                    if(audioInitialized) {
                        const now = Tone.now();
                        extraLifeSynth.triggerAttackRelease(['C5', 'G5', 'C6'], '8n', now);
                    }
                }

                updateFragmentStatusUI();
            }

            function draw() {
                ctx.clearRect(0, 0, width, height);
                ctx.imageSmoothingEnabled = false;
                if (dataStorm) dataStorm.draw(ctx); 
                if (landscape) landscape.draw(ctx);
                if (uplinkZone) uplinkZone.draw();
                
                drawWaveBackground();

                particles.forEach(p => p.draw()); 
                fragments.forEach(f => f.draw());
                enemies.forEach(e => e.draw()); 
                bullets.forEach(b => b.draw()); 
                if (player) player.draw();
                
                if (gameState !== 'start') {
                    scoreEl.textContent = `SCORE: ${score}`; 
                    livesEl.textContent = `LIVES: ${Math.max(0, lives)}`; 
                }
            }
            
            function drawWaveBackground() {
                ctx.save();
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                ctx.fillStyle = hexToRgba(glowColor, 0.1);

                ctx.font = `bold clamp(2em, 5vw, 3em) 'Orbitron', sans-serif`;
                ctx.fillText('WAVE', width / 2, height * 0.3);

                ctx.font = `bold clamp(10em, 25vw, 20em) 'Orbitron', sans-serif`;
                ctx.fillText(wave, width / 2, height * 0.6);

                ctx.restore();
            }
            
            function endGame(reason) {
                gameState = 'lose'; 
                cancelAnimationFrame(animationFrameId); 
                animationFrameId = null;
                player = null; 

                enemies = [];
                bullets = [];
                particles = [];
                fragments = [];
                
                if(audioInitialized) { 
                    bassPulse.stop(); 
                    choirSynth.releaseAll(); 
                    activeChoirNotes = []; 
                    const now = Tone.now();
                    const reversedScale = [...fragmentScale].reverse();
                    reversedScale.forEach((note, index) => {
                        decodedMessageSynth.triggerAttackRelease(note, '16n', now + index * 0.15);
                    });
                }
                
                messageOverlay.innerHTML = '';
                const title = document.createElement('h1');
                const subtext = document.createElement('p');
                const restartButton = document.createElement('button');

                title.textContent = "GAME OVER";
                subtext.innerHTML = `You reached Wave ${wave}<br>Final Score: ${score}`;
                restartButton.textContent = 'RESTART';
                restartButton.className = 'message-button';
                restartButton.id = 'restart-button'; 

                messageOverlay.appendChild(title);
                messageOverlay.appendChild(subtext);
                messageOverlay.appendChild(restartButton);
                messageOverlay.style.display = 'block';
                
                restartButton.addEventListener('click', (e) => {
                    e.stopPropagation(); 
                    launchGame();
                });
            }

            function animate(timestamp) {
                if (gameState === 'lose') {
                    if (animationFrameId) {
                        draw();
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }
                    return;
                }
                const dt = (timestamp - lastTime) / 1000; 
                lastTime = timestamp;
                
                if (gameState === 'playing') {
                    update(dt);
                }
                
                draw();
                animationFrameId = requestAnimationFrame(animate);
            }

            function resizeGame() {
                width = 800; 
                height = 600;
                canvas.width = width; 
                canvas.height = height;
                if(landscape) landscape.generatePoints();
            }

            function handlePointerDown(e) {
                 if (gameState === 'playing') {
                    if (e.target === shootButton) isShooting = true;
                    else if (e.target === joystickArea || e.target === joystickKnob) {
                        joystickActive = true; const touch = e.touches[0];
                        joystickStart.x = touch.clientX; joystickStart.y = touch.clientY;
                        joystickCurrent.x = touch.clientX; joystickCurrent.y = touch.clientY;
                    }
                }
            }

            function handlePointerMove(e) {
                if (joystickActive) {
                    e.preventDefault();
                    const touch = e.touches[0];
                    joystickCurrent.x = touch.clientX;
                    joystickCurrent.y = touch.clientY;
                    const dx = joystickCurrent.x - joystickStart.x;
                    const dy = joystickCurrent.y - joystickStart.y;
                    const dist = Math.min(50, Math.sqrt(dx * dx + dy * dy));
                    const angle = Math.atan2(dy, dx);
                    const knobX = 40 + dist * Math.cos(angle);
                    const knobY = 40 + dist * Math.sin(angle);
                    joystickKnob.style.transform = `translate(${knobX}px, ${knobY}px)`;
                }
            }

            function handlePointerUp(e) {
                isShooting = false;
                if (joystickActive) {
                    joystickActive = false;
                    joystickKnob.style.transform = `translate(40px, 40px)`;
                }
            }
            
            window.removeEventListener('resize', resizeGame);
            window.removeEventListener('keydown', handleKeyDown);
            window.removeEventListener('keyup', handleKeyUp);

            function handleKeyDown(e) {
                const key = e.key.toLowerCase();
                if (key === 'p') {
                    togglePause();
                    return;
                }
                
                if (gameState !== 'playing') return;

                keys[key] = true;
                if (key === ' ') {
                    e.preventDefault();
                    isShooting = true;
                }
            }

            function handleKeyUp(e) {
                const key = e.key.toLowerCase();
                keys[key] = false;
                if (key === ' ') {
                    isShooting = false;
                }
            }

            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            
            const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
            if (isTouchDevice) {
                touchControls.style.display = 'block';
                joystickArea.addEventListener('touchstart', handlePointerDown, { passive: false });
                shootButton.addEventListener('touchstart', handlePointerDown, { passive: false });
                window.addEventListener('touchmove', handlePointerMove, { passive: false });
                window.addEventListener('touchend', handlePointerUp);
                window.addEventListener('touchcancel', handlePointerUp);
            }
            resizeGame();
            startGame();
        }

        // --- UPDATED: Start Splash Screen Logic ---
        window.onload = () => {
            updateThemeColors();
            initCanvasBackground();
            
            const clickPrompt = document.getElementById('click-prompt');
            const bootSequenceEl = document.getElementById('boot-sequence');
            const titleEl = document.getElementById('title');
            const gameInfoEl = document.getElementById('game-info');
            const startButton = document.getElementById('start-button');
            const splashContainer = document.getElementById('splash-container');
            const messageOverlay = document.getElementById('message-overlay');

            const handleEnterKey = (e) => {
                if (e.key !== 'Enter') return;

                const startButtonVisible = !startButton.classList.contains('hidden-on-load');
                const restartButton = document.getElementById('restart-button');

                if (startButtonVisible && splashContainer.style.display !== 'none') {
                    startButton.click();
                } else if (restartButton && messageOverlay.style.display === 'block') {
                    restartButton.click();
                }
            };
            
            startButton.addEventListener('click', launchGame);

            splashContainer.addEventListener('click', () => {
                clickPrompt.style.display = 'none';
                bootSequenceEl.style.display = 'block';

                Tone.start().then(initAllAudio).then(() => {
                    if (keyClatterLoop) {
                        Tone.Transport.start();
                    }
                    
                    typeLine(); 

                    window.addEventListener('keydown', handleEnterKey);

                    const bootDuration = lines.length * 450 + 1000;

                    setTimeout(() => {
                        if (keyClatterLoop) {
                            Tone.Transport.stop();
                            keyClatterLoop.dispose();
                        }
                        bootSequenceEl.style.display = 'none';

                        titleEl.classList.remove('hidden-on-load');
                        gameInfoEl.classList.remove('hidden-on-load');
                        startButton.classList.remove('hidden-on-load');

                        splashContainer.style.display = 'flex';

                        setTimeout(() => {
                            playTitleSoundSequence();
                        }, 500);

                    }, bootDuration);
                });
            }, { once: true });
        };

    </script>
</body>
</html>
